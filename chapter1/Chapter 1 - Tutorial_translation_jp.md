# 第1章：チュートリアル

この章は、Goの基本的な構成要素を巡るツアーです。私たちは、皆さんができるだけ早く軌道に乗り、役立つことを始められるように、十分な情報と例を提供したいと考えています。ここにある例、そして実のところ本書全体の例は、皆さんが現実の世界でやらなければならないかもしれないタスクを対象としています。この章では、単純なファイル処理やちょっとしたグラフィックスから、並行インターネットクライアントやサーバーまで、Goで書くことができるプログラムの多様性を味わっていただきたいと思います。最初の章ですべてを説明するわけではありませんが、新しい言語でそのようなプログラムを学ぶことは、始めるための効果的な方法となり得ます。

新しい言語を学ぶとき、すでに知っている言語で書いていたようにコードを書くという自然な傾向があります。Goを学ぶ際にはこのバイアスに注意し、それを避けようと努めてください。私たちは良いGoの書き方を説明し、図解しようと試みてきましたので、ご自身のコードを書く際のガイドとしてここのコードを使用してください。

### 1.1. Hello, World

1978年に出版された「Cプログラミング言語」の冒頭に登場する、今や伝統となった「hello, world」の例から始めましょう。CはGoに最も直接的な影響を与えた言語の一つであり、「hello, world」は多くの中核的な考え方を示しています。

`gopl.io/ch1/helloworld`

```go
package main

import "fmt"

func main() {
    fmt.Println("Hello, BF")
}
```

Goはコンパイル言語です。Goのツールチェーンは、ソースプログラムとそれが依存するものを、コンピュータのネイティブな機械語の命令に変換します。これらのツールは、`go`という単一のコマンドを通じてアクセスされ、そのコマンドにはいくつかのサブコマンドがあります。これらのサブコマンドの中で最も単純なものは`run`で、名前が`.go`で終わる1つ以上のソースファイルからソースコードをコンパイルし、ライブラリとリンクしてから、結果の実行可能ファイルを実行します。（本書ではコマンドプロンプトとして`$`を使用します。）

```sh
$ go run helloworld.go
```

驚くことではありませんが、これは次のように出力します。

```
Hello, BF
```

GoはネイティブでUnicodeを扱えるので、世界中のすべての言語のテキストを処理できます。

プログラムが一度きりの実験以上のものである場合、一度コンパイルして、後で使用するためにコンパイル結果を保存したいと思うでしょう。それは`go build`で行います。

```sh
$ go build helloworld.go
```

これにより、`helloworld`という名前の実行可能なバイナリファイルが作成され、いつでも追加の処理なしで実行できます。

```sh
$ ./helloworld
Hello, BF
```

私たちは、gopl.ioにある本書のソースコードリポジトリからコードを入手できることを思い出させるために、すべての重要な例にラベルを付けています。

`gopl.io/ch1/helloworld`

`go get gopl.io/ch1/helloworld`を実行すると、ソースコードがフェッチされ、対応するディレクトリに配置されます。このトピックについては、セクション2.6とセクション10.7で詳しく説明します。

それでは、プログラム自体について話しましょう。Goのコードはパッケージに整理されており、これは他の言語のライブラリやモジュールに似ています。パッケージは、パッケージが何をするかを定義する単一のディレクトリ内にある1つ以上の`.go`ソースファイルで構成されています。各ソースファイルは、ファイルが属するパッケージを示す`package`宣言（ここでは`package main`）で始まり、次にそれがインポートする他のパッケージのリスト、そしてそのファイルに保存されているプログラムの宣言が続きます。

Goの標準ライブラリには、入出力、ソート、テキスト操作などの一般的なタスクのための100を超えるパッケージがあります。例えば、`fmt`パッケージには、書式設定された出力を表示したり、入力をスキャンしたりするための関数が含まれています。`Println`は`fmt`の基本的な出力関数の1つで、1つ以上の値をスペースで区切って出力し、最後に改行文字を付けて値が1行の出力として表示されるようにします。

`main`パッケージは特別です。これはライブラリではなく、スタンドアロンの実行可能プログラムを定義します。`main`パッケージ内の`main`関数も特別で、プログラムの実行がここから始まります。`main`が何をするかが、プログラムがすることです。もちろん、`main`は通常、`fmt.Println`関数のように、作業の大部分を行うために他のパッケージの関数を呼び出します。

私たちはコンパイラに、このソースファイルでどのパッケージが必要かを伝えなければなりません。それが、`package`宣言に続く`import`宣言の役割です。「hello, world」プログラムは、他の1つのパッケージから1つの関数しか使用しませんが、ほとんどのプログラムはより多くのパッケージをインポートします。
必要なパッケージを正確にインポートする必要があります。インポートが不足していたり、不要なインポートがあったりすると、プログラムはコンパイルされません。この厳格な要件により、プログラムが進歩するにつれて、未使用のパッケージへの参照が蓄積されるのを防ぎます。
`import`宣言は`package`宣言の後に記述しなければなりません。その後、プログラムは関数、変数、定数、および型の宣言で構成されます（キーワード`func`、`var`、`const`、および`type`で導入されます）。ほとんどの場合、宣言の順序は重要ではありません。このプログラムは、1つの関数しか宣言せず、その関数がさらに別の関数を1つ呼び出すだけなので、可能な限り短くなっています。スペースを節約するために、例を示す際に`package`と`import`の宣言を省略することがありますが、それらはソースファイルにあり、コードをコンパイルするためにはそこになければなりません。
関数宣言は、キーワード`func`、関数名、パラメータリスト（`main`の場合は空）、結果リスト（ここでも空）、そして関数本体（何をするかを定義する文）を中括弧で囲んだもので構成されます。関数については第5章で詳しく見ていきます。
Goでは、文や宣言の末尾にセミコロンは必要ありません。ただし、同じ行に2つ以上現れる場合は例外です。事実上、特定のトークンに続く改行はセミコロンに変換されるため、Goコードを正しく解析するには改行の位置が重要です。たとえば、関数の開き中括弧`{`は`func`宣言の終わりと同じ行になければならず、それ自体の行にあってはなりません。また、式`x + y`では、`+`演算子の後には改行が許可されますが、前には許可されません。
Goはコードのフォーマットに関して強い姿勢をとっています。`gofmt`ツールはコードを標準フォーマットに書き直し、`go`ツールの`fmt`サブコマンドは、指定されたパッケージ内のすべてのファイル、またはデフォルトで現在のディレクトリにあるファイルに`gofmt`を適用します。本書のすべてのGoソースファイルは`gofmt`を実行されており、皆さんもご自身のコードで同じことをする習慣を身につけるべきです。
標準フォーマットを布告によって宣言することは、些細なことに関する多くの無意味な議論を排除し、さらに重要なことに、任意のフォーマットが許可されていたら実現不可能だったであろう、さまざまな自動ソースコード変換を可能にします。
多くのテキストエディタは、ファイルを保存するたびに`gofmt`を実行するように設定できるため、ソースコードは常に適切にフォーマットされます。関連ツールの`goimports`は、必要に応じて`import`宣言の挿入と削除をさらに管理します。これは標準配布の一部ではありませんが、次のコマンドで入手できます。
`$ go get golang.org/x/tools/cmd/goimports`
ほとんどのユーザーにとって、パッケージをダウンロードしてビルドし、テストを実行し、ドキュメントを表示するなどの通常の方法は、`go`ツールを使用することです。これについてはセクション10.7で見ていきます。

### 1.2. コマンドライン引数

ほとんどのプログラムは何らかの入力を処理して何らかの出力を生成します。それがコンピューティングの定義とほぼ同じです。しかし、プログラムはどのようにして操作する入力データを得るのでしょうか？一部のプログラムは独自のデータを生成しますが、多くの場合、入力は外部ソースから来ます. ファイル、ネットワーク接続、別のプログラムの出力、キーボードのユーザー、コマンドライン引数などです。次のいくつかの例では、コマンドライン引数から始めて、これらの代替案のいくつかについて説明します。

`os`パッケージは、プラットフォームに依存しない方法でオペレーティングシステムを扱うための関数やその他の値を提供します。コマンドライン引数は、`os`パッケージの一部である`Args`という名前の変数としてプログラムで利用できます。したがって、`os`パッケージの外部でその名前を使用する場合は`os.Args`となります。

変数`os.Args`は文字列のスライスです。スライスはGoの基本的な概念であり、すぐに詳しく説明します。今のところ、スライスを動的にサイズ変更可能な配列要素のシーケエンスと考え、個々の要素は`s[i]`としてアクセスでき、連続したサブシーケンスは`s[m:n]`としてアクセスできます。要素の数は`len(s)`で与えられます。ほとんどの他のプログラミング言語と同様に、Goのすべてのインデックス付けは、最初のインデックスを含み、最後のインデックスを除外する半開区間を使用します。これはロジックを簡素化するためです。たとえば、`s[m:n]`というスライスは、`0 ≤ m ≤ n ≤ len(s)`の場合、`n-m`個の要素を含みます。

`os.Args`の最初の要素、`os.Args[0]`はコマンド自体の名前です。他の要素は、プログラムが実行を開始したときに提供された引数です。`s[m:n]`という形式のスライス式は、要素`m`から`n-1`を参照するスライスを生成するため、次の例で必要となる要素はスライス`os.Args[1:len(os.Args)]`に含まれるものです。`m`または`n`が省略された場合、それぞれ`0`または`len(s)`がデフォルトとなるため、目的のスライスを`os.Args[1:]`と略記できます。

これはUnixの`echo`コマンドの実装です。このコマンドはコマンドライン引数を1行に出力します。2つのパッケージをインポートしており、個々の`import`宣言ではなく括弧で囲まれたリストとして与えられています。どちらの形式も合法ですが、慣習的にはリスト形式が使用されます。`import`の順序は重要ではありません。`gofmt`ツールはパッケージ名をアルファベット順にソートします。（例の複数のバージョンがある場合、どれについて話しているかを明確にするために番号を付けることがよくあります。）

`gopl.io/ch1/helloworld`

```go
// Echo1 prints its command-line arguments.
package main
import (
"fmt"
"os"
)
```

```go
func main() {
    var s, sep string
    for i := 1; i < len(os.Args); i++ {
        s += sep + os.Args[i]
        sep = " "
    }
    fmt.Println(s)
}
```

コメントは `//` で始まります。`//` から行末までのすべてのテキストはプログラマのための注釈であり、コンパイラによって無視されます。慣習として、各パッケージをそのパッケージ宣言の直前のコメントで説明します。`main` パッケージの場合、このコメントはプログラム全体を説明する1つ以上の完全な文です。

`var` 宣言は、`string` 型の2つの変数 `s` と `sep` を宣言します。変数は宣言の一部として初期化できます。明示的に初期化されていない場合、その型のゼロ値に暗黙的に初期化されます。数値型の場合は `0`、文字列の場合は空の文字列 `""` です。したがって、この例では、宣言は `s` と `sep` を暗黙的に空の文字列に初期化します。変数と宣言については、第2章で詳しく説明します。

数値の場合、Goは通常の算術演算子と論理演算子を提供します。ただし、文字列に適用される場合、`+` 演算子は値を連結するため、式
`sep + os.Args[i]`
は、文字列 `sep` と `os.Args[i]` の連結を表します。プログラムで使用した文、
`s += sep + os.Args[i]`
は、`s` の古い値を `sep` および `os.Args[i]` と連結し、それを `s` に代入し直す代入文です。これは以下と等価です。
`s = s + sep + os.Args[i]`
演算子 `+=` は代入演算子です。`+` や `*` のような各算術演算子と論理演算子には、対応する代入演算子があります。

`echo` プログラムは出力をループ内で1つずつ表示することもできましたが、このバージョンでは代わりに、新しいテキストを末尾に繰り返し追加することによって文字列を構築しています。文字列 `s` は空、つまり値 `""` で始まり、ループを通過するたびにテキストが追加されます。最初の反復の後、スペースも挿入されるため、ループが終了すると、各引数の間に1つのスペースが入ります。これは二次プロセス（quadratic process）であり、引数の数が多い場合はコストがかかる可能性がありますが、`echo` の場合、その可能性は低いです。この章と次の章では、実際の非効率性に対処する `echo` の改良版をいくつか紹介します。

ループインデックス変数 `i` は、`for` ループの最初の部分で宣言されています。記号 `:=` は、1つ以上の変数を宣言し、初期化子の値に基づいて適切な型を与える文である短い変数宣言の一部です。これについては、次の章で詳しく説明します。

インクリメント文 `i++` は `i` に 1 を加算します。これは `i += 1` と等価であり、さらに `i = i + 1` と等価です。1 を減算する対応するデクリメント文 `i--` があります。これらは文であり、C言語ファミリーのほとんどの言語のように式ではないため、`j = i++` は不正であり、これらは後置のみであるため、`--i` も不正です。

`for` ループは、Goにおける唯一のループ文です。いくつかの形式があり、そのうちの1つを以下に示します。

```go
for initialization; condition; post {
    // zero or more statements
}
```

括弧は `for` ループの3つの構成要素の周りには使用されません。ただし、中括弧は必須であり、開き中括弧は `post` 文と同じ行になければなりません。

オプションの `initialization`（初期化）文は、ループが始まる前に実行されます。存在する場合、それは単純な文、つまり短い変数宣言、インクリメントまたは代入文、または関数呼び出しでなければなりません。`condition`（条件）は、ループの各反復の開始時に評価されるブール式です。これが真と評価されると、ループによって制御される文が実行されます。`post` 文はループの本体の後に実行され、その後、条件が再度評価されます。条件が偽になるとループは終了します。

これらの部分はいずれも省略可能です。初期化と事後処理がない場合、セミコロンも省略できます。

```go
// a traditional "while" loop
for condition {
    // ...
}
```

条件がこれらの形式のいずれかで完全に省略された場合、例えば
```go
// a traditional infinite loop
for {
    // ...
}
```
では、ループは無限ですが、この形式のループは `break` や `return` 文のような他の方法で終了させることができます。

`for` ループの別の形式は、文字列やスライスなどのデータ型からの値の範囲（range）を反復処理します。説明のために、`echo` の2番目のバージョンを以下に示します。

`gopl.io/ch1/echo2`

```go
// Echo2 prints its command-line arguments.
package main

import (
    "fmt"
    "os"
)

func main() {
    s, sep := "", ""
    for _, arg := range os.Args[1:] {
        s += sep + arg
        sep = " "
    }
    fmt.Println(s)
}
```

ループの各反復において、`range` はインデックスと、そのインデックスにある要素の値のペアを生成します。この例ではインデックスは必要ありませんが、`range` ループの構文では、要素を処理する場合、インデックスも処理する必要があります。1つのアイデアは、インデックスを `temp` のような明らかな一時変数に代入してその値を無視することですが、Goでは未使用のローカル変数は許可されていないため、これはコンパイルエラーになります。

解決策は、名前が `_`（アンダースコア）である **ブランク識別子**（blank identifier）を使用することです。ブランク識別子は、構文上変数名が必要だがプログラムのロジック上は必要ない場合、例えば要素の値のみが必要で不要なループインデックスを破棄する場合などに使用できます。ほとんどのGoプログラマは、`os.Args` のインデックス作成が明示的ではなく暗黙的であり、その方が正しく記述しやすいため、上記のように `range` と `_` を使用して `echo` プログラムを記述するでしょう。

このバージョンのプログラムでは、短縮変数宣言を使用して `s` と `sep` を宣言および初期化していますが、変数を個別に宣言することも同様に可能です。文字列変数を宣言する方法はいくつかあります。これらはすべて等価です。

```s
s := ""
var s string
var s = ""
var s string = ""
```

なぜある形式を別の形式よりも好むべきなのでしょうか？最初の形式である短縮変数宣言は最もコンパクトですが、関数内でのみ使用でき、パッケージレベルの変数には使用できません。2番目の形式は、文字列のゼロ値である `""` へのデフォルトの初期化に依存しています。3番目の形式は、複数の変数を宣言する場合を除いて、めったに使用されません。4番目の形式は変数の型を明示していますが、これは初期値の型と同じである場合は冗長ですが、型が異なる他の場合には必要です。実際には、通常、最初の2つの形式のいずれかを使用し、初期値が重要であることを示すには明示的な初期化を行い、初期値が重要でないことを示すには暗黙的な初期化を行うべきです。

上述のように、ループを通過するたびに、文字列 `s` は完全に新しい内容を取得します。`+=` 文は、古い文字列、スペース文字、および次の引数を連結して新しい文字列を作成し、その新しい文字列を `s` に代入します。`s` の以前の内容はもう使用されないため、やがてガベージコレクションされます。

関与するデータの量が多い場合、これはコストがかかる可能性があります。よりシンプルで効率的な解決策は、`strings` パッケージの `Join` 関数を使用することです。

`gopl.io/ch1/echo3`

```go
func main() {
    fmt.Println(strings.Join(os.Args[1:], " "))
}
```

最後に、フォーマットは気にせず値を確認したいだけの場合（おそらくデバッグのため）、`Println` に結果をフォーマットさせることができます。

```go
fmt.Println(os.Args[1:])
```

この文の出力は `strings.Join` から得られるものと似ていますが、周囲に角括弧が付きます。任意のスライスをこの方法で表示できます。

**練習問題 1.1:** `echo` プログラムを修正して、それを呼び出したコマンドの名前である `os.Args[0]` も表示するようにしてください。

**練習問題 1.2:** `echo` プログラムを修正して、引数のインデックスと値を1行に1つずつ表示するようにしてください。

**練習問題 1.3:** 潜在的に非効率的なバージョンと `strings.Join` を使用するバージョンの実行時間の違いを測定する実験をしてください（セクション1.6では `time` パッケージの一部を示し、セクション11.4では体系的なパフォーマンス評価のためのベンチマークテストの書き方を示します）。

### 1.3. 重複行の検索

ファイルのコピー、印刷、検索、ソート、カウントなどを行うプログラムはすべて、似たような構造を持っています：入力に対するループ、各要素に対する何らかの計算、そしてその場または最後での出力生成です。ここでは `dup` という名前のプログラムの3つのバリエーションを紹介します。これは、隣接する重複行を探す Unix の `uniq` コマンドから一部着想を得ています。使用される構造とパッケージは、簡単に適応させることができるモデルです。

最初のバージョンの `dup` は、標準入力に2回以上現れる各行を、その回数とともに表示します。このプログラムでは、`if` 文, `map` データ型, および `bufio` パッケージを紹介します。

`gopl.io/ch1/dup1`

```go
// Dup1 prints the text of each line that appears more than
// once in the standard input, preceded by its count.
package main

import (
    "bufio"
    "fmt"
    "os"
)

func main() {
    counts := make(map[string]int)
    input := bufio.NewScanner(os.Stdin)
    for input.Scan() {
        counts[input.Text()]++
    }
    // NOTE: ignoring potential errors from input.Err()
    for line, n := range counts {
        if n > 1 {
            fmt.Printf("%d\t%s\n", n, line)
        }
    }
}
```

`for` と同様に、`if` 文の条件を括弧で囲むことはありませんが、本体には中括弧が必須です。条件が偽の場合に実行されるオプションの `else` 部分を指定することもできます。

`map` はキーと値のペアのセットを保持し、セット内の項目の格納、取得、またはテストのための定数時間操作を提供します。キーは `==` で比較できる任意の種類（文字列が最も一般的な例です）で、値は全く任意の種類です。この例では、キーは文字列で、値は整数 (`int`) です。組み込み関数 `make` は新しい空のマップを作成します。これには他にも用途があります。マップについては、第4.3節で詳しく説明します。

`dup` が入力の行を読み込むたびに、その行がマップへのキーとして使用され、対応する値がインクリメントされます。文 `counts[input.Text()]++` は、次の2つの文と等価です。

```go
line := input.Text()
counts[line] = counts[line] + 1
```

マップにそのキーがまだ含まれていなくても問題ありません。新しい行が初めて現れたとき、右側の式 `counts[line]` は、その型のゼロ値（`int` の場合は `0`）に評価されます。

結果を表示するには、もう1つの `range` ベースの `for` ループを使用します。今回は `counts` マップに対してです。以前と同様に、各反復は2つの結果（キーとそのキーに対するマップ要素の値）を生成します。マップの反復順序は指定されていませんが、実際には実行ごとに異なり、ランダムです。この設計は意図的なものであり, 保証されていない特定の順序にプログラムが依存するのを防ぐためです。

続いて `bufio` パッケージです。これは入出力を効率的で便利なものにするのに役立ちます。その最も有用な機能の1つは、入力を読み込んで行や単語に分解する `Scanner` という型です。これは、自然に行単位で提供される入力を処理する最も簡単な方法であることが多いです。

スキャナはプログラムの標準入力から読み取ります。`input.Scan()` を呼び出すたびに、次の行を読み取り、末尾の改行文字を削除します。その結果は `input.Text()` を呼び出すことで取得できます。`Scan` 関数は、行がある場合は `true` を返し、入力がなくなると `false` を返します。

プログラムは、新しい `bufio.Scanner` を参照する新しい変数 `input` を作成するために、短縮変数宣言を使用しています。

```go
input := bufio.NewScanner(os.Stdin)
```

`fmt.Printf` 関数は、C言語や他の言語の `printf` と同様に、式やリストから書式付きの出力を生成します。最初の引数は、後続の引数をどのように書式設定するかを指定する書式文字列（format string）です。各引数の書式は、パーセント記号の後に続く文字である変換文字（conversion character）によって決定されます。たとえば、`%d` は整数オペランドを 10 進数表記で書式設定し、`%s` は文字列オペランドの値に展開されます。

`Printf` には 10 種類以上の変換があり、Go プログラマはこれらを**動詞**（verbs）と呼びます。この表は完全な仕様ではありませんが、利用可能な機能の多くを示しています：

| 動詞 | 説明 |
| :--- | :--- |
| `%d` | 10 進整数 |
| `%x`, `%o`, `%b` | 16 進数、8 進数、2 進数の整数 |
| `%f`, `%g`, `%e` | 浮動小数点数: 3.141593 3.141592653589793 3.141593e+00 |
| `%t` | ブール値: true または false |
| `%c` | rune（Unicode コードポイント） |
| `%s` | 文字列 |
| `%q` | 引用符付き文字列 "abc" または rune 'c' |
| `%v` | 自然な形式の任意の値 |
| `%T` | 任意の値の型 |
| `%%` | パーセント記号そのもの（オペランドなし） |

`dup1` の書式文字列には、タブ `\t` と改行 `\n` も含まれています。文字列リテラルには、本来見えない文字を表すために、このようなエスケープシーケンス（escape sequences）を含めることができます。`Printf` はデフォルトでは改行を書き込みません。慣習として、`log.Printf` や `fmt.Errorf` のように名前が `f` で終わる書式指定関数は、`fmt.Printf` の書式規則を使用します。一方、名前が `ln` で終わる関数は `Println` に従い、引数を `%v` であるかのように書式設定し、その後に改行を続けます。

多くのプログラムは、上記のように標準入力から読み取るか、名前付きファイルのシーケンスから読み取ります。`dup` の次のバージョンでは、標準入力から読み取るか、`os.Open` を使用して各ファイルを開き、ファイル名のリストを処理することができます。

`dup` の次のバージョンは、標準入力から、または名前付きファイルのリストから読み取ることができます。

```go
func main() {
    counts := make(map[string]int)
    files := os.Args[1:]
    if len(files) == 0 {
        countLines(os.Stdin, counts)
    } else {
        for _, arg := range files {
            f, err := os.Open(arg)
            if err != nil {
                fmt.Fprintf(os.Stderr, "dup2: %v\n", err)
                continue
            }
            countLines(f, counts)
            f.Close()
        }
    }
    for line, n := range counts {
        if n > 1 {
            fmt.Printf("%d\t%s\n", n, line)
        }
    }
}

func countLines(f *os.File, counts map[string]int) {
    input := bufio.NewScanner(f)
    for input.Scan() {
        counts[input.Text()]++
    }
    // NOTE: ignoring potential errors from input.Err()
}
```

`os.Open` 関数は2つの値を返します。1つ目は、`Scanner` によるその後の読み取りで使用される開かれたファイル (`*os.File`) です。

`os.Open` の2番目の結果は、組み込みの `error` 型の値です。`err` が特別な組み込み値 `nil` と等しい場合、ファイルは正常に開かれました。ファイルが読み取られ、入力の終わりに達すると、`Close` がファイルを閉じ、リソースを解放します。一方、`err` が `nil` でない場合は、何らかの問題が発生しました。その場合、エラー値が問題を説明します。私たちの単純なエラー処理では、`Fprintf` と動詞 `%v`（任意の型の値をデフォルトの形式で表示する）を使用して標準エラーストリームにメッセージを表示し、`dup` は次のファイルに進みます。`continue` 文は、それを囲む `for` ループの次の反復に移動します。

コードサンプルを妥当なサイズに保つために、初期の例ではエラー処理について意図的にやや「無頓着」 (cavalier) になっています。明らかに `os.Open` からのエラーをチェックする必要がありますが、`input.Scan` でファイルを読み取っている間にエラーが発生する可能性（これはより低いですが）は無視しています。エラーチェックをスキップした場所は注記し、第5.4節でエラー処理の詳細について説明します。

`countLines` への呼び出しがその宣言よりも前にあることに注目してください。関数やその他のパッケージレベルのエンティティは、任意の順序で宣言できます。

マップは、`make` によって作成されたデータ構造への **参照** (reference) です。マップが関数に渡されると、関数は参照のコピーを受け取るため、呼び出された関数が基礎となるデータ構造に加えた変更は、呼び出し元のマップ参照を通じても見えるようになります。この例では、`countLines` によって `counts` マップに挿入された値は `main` からも見えます。

上記の `dup` のバージョンは、入力が必要に応じて読み込まれ、行に分割される「ストリーミング」モードで動作するため、原理的にはこれらのプログラムは任意の量の入力を処理できます。別の方法は、入力全体を一気に (in one big gulp) メモリに読み込み、一度にすべてを行に分割してから、行を処理することです。次のバージョン `dup3` はそのように動作します。これは、指定されたファイルの内容全体を読み取る `ReadFile` 関数 (`io/ioutil` パッケージから) と、文字列を部分文字列のスライスに分割する `strings.Split` を導入します。（`Split` は、以前に見た `strings.Join` の逆です。）

`dup3`をいくらか簡略化しました。第一に、`ReadFile`はファイル名の引数を必要とするため、標準入力ではなく、名前付きファイルのみを読み込みます。第二に、行のカウントは現在1か所でのみ必要とされるため、`main`に戻しました。

`gopl.io/ch1/dup3`

```go
package main

import (
    "fmt"
    "io/ioutil"
    "os"
    "strings"
)

func main() {
    counts := make(map[string]int)
    for _, filename := range os.Args[1:] {
        data, err := ioutil.ReadFile(filename)
        if err != nil {
            fmt.Fprintf(os.Stderr, "dup3: %v\n", err)
            continue
        }
        for _, line := range strings.Split(string(data), "\n") {
            counts[line]++
        }
    }
    for line, n := range counts {
        if n > 1 {
            fmt.Printf("%d\t%s\n", n, line)
        }
    }
}
```

`ReadFile`はバイトスライス（byte slice）を返しますが、`strings.Split`で分割できるようにするには、これを文字列（string）に変換する必要があります。文字列とバイトスライスについては、セクション3.5.4で詳しく説明します。

内部的には（Under the covers）、`bufio.Scanner`、`ioutil.ReadFile`、`ioutil.WriteFile`は`*os.File`の`Read`と`Write`メソッドを使用していますが、ほとんどのプログラマがそれらの低レベルなルーチンに直接アクセスする必要があることは稀です。`bufio`や`io/ioutil`のような高レベルな関数の方が使いやすいです。

**練習問題 1.4:** 重複した行が発生するすべてのファイルの名前を表示するように`dup2`を変更しなさい。

### 1.4. アニメーションGIF

次のプログラムは、Goの標準 `image` パッケージの基本的な使用法を示しています。これを使用して、ビットマップ画像のシーケンスを作成し、そのシーケンスをGIFアニメーションとしてエンコードします。リサージュ図形（Lissajous figures）と呼ばれるこれらの画像は、1960年代のSF映画で定番の視覚効果でした。これらは、オシロスコープのx入力とy入力に供給される2つの正弦波のように、2次元の調和振動によって生成されるパラメータ曲線です。図1.1にいくつかの例を示します。

図1.1. 4つのリサージュ図形。

このコードには、`const` 宣言、`struct` 型、複合リテラル（composite literals）など、いくつかの新しい構造があります。私たちのほとんどの例とは異なり、この例では浮動小数点計算も行います。ここではこれらのトピックについて簡単に説明するにとどめ、詳細は後の章に譲ります。現在の主な目的は、Goがどのようなものか、そして言語とそのライブラリを使用してどのようなことが簡単にできるかを知ってもらうことだからです。

`gopl.io/ch1/lissajous`

```go
// Lissajous generates GIF animations of random Lissajous figures.
package main

import (
    "image"
    "image/color"
    "image/gif"
    "io"
    "math"
    "math/rand"
    "os"
)

var palette = []color.Color{color.White, color.Black}

const (
    whiteIndex = 0 // first color in palette
    blackIndex = 1 // next color in palette
)

func main() {
    lissajous(os.Stdout)
}

func lissajous(out io.Writer) {
    const (
        cycles  = 5     // number of complete x oscillator revolutions
        res     = 0.001 // angular resolution
        size    = 100   // image canvas covers [-size..+size]
        nframes = 64    // number of animation frames
        delay   = 8     // delay between frames in 10ms units
    )
    freq := rand.Float64() * 3.0 // relative frequency of y oscillator
    anim := gif.GIF{LoopCount: nframes}
    phase := 0.0 // phase difference
    for i := 0; i < nframes; i++ {
        rect := image.Rect(0, 0, 2*size+1, 2*size+1)
        img := image.NewPaletted(rect, palette)
        for t := 0.0; t < cycles*2*math.Pi; t += res {
            x := math.Sin(t)
            y := math.Sin(t*freq + phase)
            img.SetColorIndex(size+int(x*size+0.5), size+int(y*size+0.5),
                blackIndex)
        }
        phase += 0.1
        anim.Delay = append(anim.Delay, delay)
        anim.Image = append(anim.Image, img)
    }
    gif.EncodeAll(out, &anim) // NOTE: ignoring encoding errors
}
```

`image/color` のようにパスに複数のコンポーネントが含まれるパッケージをインポートした後、最後のコンポーネントからの名前でパッケージを参照します。したがって、変数 `color.White` は `image/color` パッケージに属し、`gif.GIF` は `image/gif` に属します。

`const` 宣言（§3.6）は、定数（constants）、つまり、サイクル、フレーム、遅延の数値パラメータなど、コンパイル時に固定される値に名前を付けます。`var` 宣言と同様に、`const` 宣言はパッケージレベル（名前がパッケージ全体で見えるようにするため）または関数内（名前がその関数内でのみ見えるようにするため）に現れることができます。定数の値は、数値、文字列、またはブール値でなければなりません。

式 `[]color.Color{...}` および `gif.GIF{...}` は複合リテラル（composite literals）（§4.2, §4.4.1）であり、一連の要素値からGoの複合型をインスタンス化するためのコンパクトな表記法です。ここでは、最初のものはスライスで、2番目のものは構造体（struct）です。

`gif.GIF` 型は構造体（struct）型です（§4.4）。構造体とは、フィールド（fields）と呼ばれる値のグループで、多くの場合異なる型を持ち、1つのユニットとして扱える単一のオブジェクトにまとめられたものです。変数 `anim` は `gif.GIF` 型の構造体です。構造体リテラルは、`LoopCount` フィールドが `nframes` に設定された構造体値を作成します。他のすべてのフィールドは、その型のゼロ値を持ちます。構造体の個々のフィールドには、`anim` の `Delay` フィールドと `Image` フィールドを明示的に更新する最後の2つの代入のように、ドット記法（dot notation）を使用してアクセスできます。

`lissajous` 関数には2つの入れ子になったループがあります。外側のループは64回実行され、それぞれがアニメーションの単一のフレームを生成します。これは、白と黒の2色のパレットを持つ新しい201x201の画像を作成します。すべてのピクセルは、最初にはパレットのゼロ値（パレット内の0番目の色）に設定されており、これは白に設定されています。内側のループを通過するたびに、いくつかのピクセルを黒に設定することで新しい画像が生成されます。その結果は、組み込みの `append` 関数（§4.2.1）を使用して、指定された80msの遅延とともに `anim` のフレームリストに追加されます。最後に、フレームと遅延のシーケンスがGIF形式にエンコードされ、出力ストリーム `out` に書き込まれます。`out` の型は `io.Writer` であり、これによって後ほど示すように、幅広い宛先に書き込むことができます。

内側のループは2つのオシレーター（発振器）を実行します。x軸のオシレーターは単なるサイン関数です。y軸のオシレーターも正弦波ですが、x軸のオシレーターに対する周波数は0から3の間の乱数であり、x軸のオシレーターに対する位相は最初はゼロですが、アニメーションの各フレームごとに増加します。ループはx軸のオシレーターが5サイクル完了するまで実行されます。各ステップで、`(x, y)` に対応するピクセルを黒（パレットの1番目の位置）に着色するために `SetColorIndex` を呼び出します。

`main` 関数は `lissajous` 関数を呼び出し、標準出力に書き込むように指示します。そのため、このコマンドは図1.1のようなフレームを持つアニメーションGIFを生成します。
```bash
$ go build gopl.io/ch1/lissajous
$ ./lissajous >out.gif
```

練習問題 1.5：リアリティを高めるために、Lissajousプログラムのカラーパレットを黒背景の緑に変更してください。Webカラー #RRGGBB を作成するには、`color.RGBA{0xRR, 0xGG, 0xBB, 0xff}` を使用します。ここで、各16進数のペアはピクセルの赤、緑、または青の成分の強度を表します。

練習問題 1.6：パレットにさらに値を追加し、`SetColorIndex` の第3引数を興味深い方法で変更することで、複数の色で画像を生成するようにLissajousプログラムを修正してください。

### 1.5. URLの取得 (Fetching a URL)

多くのアプリケーションにとって、インターネットからの情報へのアクセスは、ローカルファイルシステムへのアクセスと同じくらい重要です。Goは、`net`の下にグループ化されたパッケージのコレクションを提供しており、インターネットを介した情報の送受信、低レベルのネットワーク接続、サーバーのセットアップを容易にします。これらにはGoの並行性機能（第8章で紹介）が特に役立ちます。

HTTPを介して情報を取得するために最低限必要なことを示すために、指定された各URLの内容を取得し、解釈されないテキストとして出力する`fetch`という単純なプログラムを以下に示します。これは非常に有用なユーティリティ`curl`に着想を得たものです。通常、このようなデータを使ってさらに多くのことを行いますが、これは基本的な考え方を示しています。本書では、このプログラムを頻繁に使用します。

`gopl.io/ch1/fetch`

```go
// FetchはURLで見つかった内容を表示します。
package main

import (
	"fmt"
	"io/ioutil"
	"net/http"
	"os"
)

func main() {
	for _, url := range os.Args[1:] {
		resp, err := http.Get(url)
		if err != nil {
			fmt.Fprintf(os.Stderr, "fetch: %v\n", err)
			os.Exit(1)
		}
		b, err := ioutil.ReadAll(resp.Body)
		resp.Body.Close() // リソースをリークさせない
		if err != nil {
			fmt.Fprintf(os.Stderr, "fetch: reading %s: %v\n", url, err)
			os.Exit(1)
		}
		fmt.Printf("%s", b)
	}
}
```

このプログラムは、`net/http`と`io/ioutil`という2つのパッケージの関数を導入しています。`http.Get`関数はHTTPリクエストを作成し、エラーがなければ、結果をレスポンス構造体`resp`で返します。`resp`の`Body`フィールドには、読み取り可能なストリームとしてのサーバーレスポンスが含まれています。次に、`ioutil.ReadAll`がレスポンス全体を読み取り、その結果は`b`に格納されます。リソースのリーク（leaking resources）を避けるために`Body`ストリームは閉じられ、`Printf`がレスポンスを標準出力に書き込みます。

```bash
$ go build gopl.io/ch1/fetch
$ ./fetch http://gopl.io
<html>
<head>
<title>The Go Programming Language</title>
...
```

HTTPリクエストが失敗した場合、`fetch`は代わりに失敗を報告します。

```bash
$ ./fetch http://bad.gopl.io
fetch: Get http://bad.gopl.io: dial tcp: lookup bad.gopl.io: no such host
```

どちらのエラーケースでも、`os.Exit(1)`によってプロセスはステータスコード1で終了します。

**練習問題 1.7:** 関数呼び出し`io.Copy(dst, src)`は`src`から読み取り、`dst`に書き込みます。`ioutil.ReadAll`の代わりに使用して、ストリーム全体を保持するのに十分な大きさのバッファを必要とせずに、レスポンスボディを`os.Stdout`にコピーしてください。`io.Copy`のエラー結果を確認することを忘れないでください。

**練習問題 1.8:** URL引数に`http://`というプレフィックスが欠落している場合、それを各URL引数に追加するように`fetch`を修正してください。`strings.HasPrefix`を使用するとよいでしょう。

**練習問題 1.9:** `resp.Status`にあるHTTPステータスコードも表示するように`fetch`を修正してください。

### 1.6. URLの並行取得 (Fetching URLs Concurrently)

Goの最も興味深く斬新な側面の一つは、並行プログラミング（concurrent programming）のサポートです。これは大きなトピックであり、第8章と第9章で詳しく説明します。そのため、ここではGoの主要な並行メカニズムであるゴルーチン（goroutines）とチャネル（channels）を少しだけ紹介します。

次のプログラム `fetchall` は、前の例と同じURLの内容の取得を行いますが、多くのURLをすべて並行して（同時に）取得します。そのため、プロセス全体にかかる時間は、すべての取得時間の合計ではなく、最も長い取得時間と同じになります。このバージョンの `fetchall` はレスポンスの内容を破棄しますが、それぞれのサイズと経過時間を報告します。

`gopl.io/ch1/fetchall`

```go
// FetchallはURLを並列に取得し、その時間とサイズを報告します。
package main

import (
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"os"
	"time"
)

func main() {
	start := time.Now()
	ch := make(chan string)
	for _, url := range os.Args[1:] {
		go fetch(url, ch) // ゴルーチンを開始する
	}
	for range os.Args[1:] {
		fmt.Println(<-ch) // チャネル ch から受信する
	}
	fmt.Printf("%.2fs elapsed\n", time.Since(start).Seconds())
}

func fetch(url string, ch chan<- string) {
	start := time.Now()
	resp, err := http.Get(url)
	if err != nil {
		ch <- fmt.Sprint(err) // チャネル ch へ送信する
		return
	}
	nbytes, err := io.Copy(ioutil.Discard, resp.Body)
	resp.Body.Close() // リソースをリークさせない
	if err != nil {
		ch <- fmt.Sprintf("while reading %s: %v", url, err)
		return
	}
	secs := time.Since(start).Seconds()
	ch <- fmt.Sprintf("%.2fs %7d %s", secs, nbytes, url)
}
```

以下に例を示します。

```bash
$ go build gopl.io/ch1/fetchall
$ ./fetchall https://golang.org http://gopl.io https://godoc.org
0.14s    6852  https://godoc.org
0.16s    7261  https://golang.org
0.48s    2475  http://gopl.io
0.48s elapsed
```

**ゴルーチン（goroutine）**は、関数の並行した実行です。**チャネル（channel）**は、あるゴルーチンから別のゴルーチンへ指定された型の値を渡すことを可能にする通信メカニズムです。関数 `main` はゴルーチンの中で実行され、`go` 文は追加のゴルーチンを作成します。

`main` 関数は `make` を使用して文字列のチャネルを作成します。各コマンドライン引数に対して、最初の `range` ループ内の `go` 文が新しいゴルーチンを開始し、`fetch` を非同期に（asynchronously）呼び出して `http.Get` でURLを取得します。`io.Copy` 関数はレスポンスのボディを読み取り、それを `ioutil.Discard` 出力ストリームに書き込むことで破棄します。`Copy` はバイト数と, 発生したエラーを返します。各結果が到着すると、`fetch` はチャネル `ch` に要約行を送信します。`main` 内の2番目の `range` ループは、それらの行を受信して出力します。

あるゴルーチンがチャネルで送信または受信を試みると、別のゴルーチンが対応する受信または送信操作を試みるまでブロック（blocks）されます。その時点で値が転送され、両方のゴルーチンが続行されます。この例では、各 `fetch` がチャネル `ch` に値（`ch <- expression`）を送信し、`main` がそれらすべてを受信（`<-ch`）します。すべての出力を `main` で行うことにより、各ゴルーチンからの出力が1つの単位として処理されることが保証され、2つのゴルーチンが同時に終了しても出力が混ざり合う（interleaving）危険性がなくなります。

**練習問題 1.10:** 大量のデータを生成するウェブサイトを見つけてください。`fetchall` を2回連続で実行して、報告される時間が大きく変わるかどうかを確認し、キャッシュ（caching）について調査してください。毎回同じ内容が得られますか？ `fetchall` を修正して、出力をファイルに書き込むようにし、内容を調べられるようにしてください。

**練習問題 1.11:** alexa.com で公開されている上位100万サイト host サンプルなど、より長い引数リストで `fetchall` を試してください。ウェブサイトが全く応答しない場合、プログラムはどのように動作しますか？（セクション8.9では、そのような場合に対処するためのメカニズムについて説明しています。）

### 1.7. Webサーバー (A Web Server)

Goのライブラリを使用すると、`fetch` プログラムによって行われるようなクライアントリクエストに応答するWebサーバーを簡単に作成できます。このセクションでは、サーバーへのアクセスに使用されたURLのパスコンポーネント（path component）を返す、最小限のサーバーを紹介します。つまり、リクエストが `http://localhost:8000/hello` の場合、レスポンスは `URL.Path = "/hello"` になります。

`gopl.io/ch1/server1`

```go
// Server1は最小限の "echo" サーバーです。
package main

import (
	"fmt"
	"log"
	"net/http"
)

func main() {
	http.HandleFunc("/", handler) // 各リクエストはhandlerを呼び出す
	log.Fatal(http.ListenAndServe("localhost:8000", nil))
}

// handlerはリクエストURL r の Path コンポーネントをエコーします。
func handler(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, "URL.Path = %q\n", r.URL.Path)
}
```

ライブラリ関数がほとんどの作業を行うため、プログラムはわずか数行の長さです。`main` 関数は、`/` で始まるすべてのURL（つまりすべてのURL）にハンドラー関数（`handler`）を接続し、ポート8000で入力リクエストをリッスンするサーバーを開始します。リクエストは `http.Request` 型の構造体として表され, そこにはいくつか関連するフィールドが含まれています。その一つが入力リクエストのURLです。リクエストが到着すると, それは `handler` 関数に渡され, `handler` 関数はリクエストURLからパスコンポーネント（`/hello`）を抽出し, `fmt.Fprintf` を使用してそれをレスポンスとして送り返します。Webサーバーについては, セクション7.7で詳しく説明します。

サーバーをバックグラウンドで開始してみましょう。Mac OS XまたはLinuxでは、コマンドにアンパサンド（`&`）を追加します。Microsoft Windowsでは、アンパサンドなしで別のコマンドウィンドウでコマンドを実行する必要があります。

```bash
$ go run code/chapter1/server1.go &
```

その後、コマンドラインからクライアントリクエストを行うことができます。

```bash
$ ./fetch http://localhost:8000
URL.Path = "/"
$ ./fetch http://localhost:8000/help
URL.Path = "/help"
```

あるいは、Webブラウザからサーバーにアクセスすることもできます。

サーバーに機能を追加するのは簡単です。便利な追加機能の一つは、何らかのステータスを返す特定のURLです。たとえば、このバージョンは同じエコーを行いますが、リクエストの数もカウントします。`/count` URLへのリクエストは、これまでのカウント（`/count` リクエスト自体を除く）を返します。

`gopl.io/ch1/server2`

```go
// Server2は最小限の "echo" およびカウンターサーバーです。
package main

import (
	"fmt"
	"log"
	"net/http"
	"sync"
)

var mu sync.Mutex
var count int

func main() {
	http.HandleFunc("/", handler)
	http.HandleFunc("/count", counter)
	log.Fatal(http.ListenAndServe("localhost:8000", nil))
}

// handlerはリクエストされたURLのPathコンポーネントをエコーします。
func handler(w http.ResponseWriter, r *http.Request) {
	mu.Lock()
	count++
	mu.Unlock()
	fmt.Fprintf(w, "URL.Path = %q\n", r.URL.Path)
}

// counterはこれまでの呼び出し回数をエコーします。
func counter(w http.ResponseWriter, r *http.Request) {
	mu.Lock()
	fmt.Fprintf(w, "Count %d\n", count)
	mu.Unlock()
}
```

サーバーには2つのハンドラーがあり、リクエストURLによってどちらが呼び出されるかが決まります。`/count` へのリクエストは `counter` を呼び出し, それ以外はすべて `handler` を呼び出します。スラッシュで終わるハンドラーパターンは, そのパターンをプレフィックスとして持つすべてのURLに一致します。舞台裏では, サーバーは各入力リクエストに対して個別のゴルーチンでハンドラーを実行するため, 複数のリクエストを同時に処理できます。しかし, 2つの並行なリクエストが同時に `count` を更新しようとすると, 一貫してインクリメントされない可能性があります。プログラムには **競合状態 (race condition)** （§9.1）と呼ばれる深刻なバグが発生することになります。この問題を避けるために, 一度に最大一つのゴルーチンだけが変数にアクセスするように保証しなければなりません。それが, `count` への各アクセスを囲む `mu.Lock()` と `mu.Unlock()` 呼び出しの目的です。共有変数を用いた並行性については, 第9章で詳しく見ていきます。

より詳細な例として、handler関数は受信したヘッダーやフォームデータを報告することができ、リクエストの検査（inspecting）やデバッグに役立つサーバーになります。

**gopl.io/ch1/server3**
```go
// handlerはHTTPリクエストをエコー（返送）します。
func handler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, "%s %s %s\n", r.Method, r.URL, r.Proto)
    for k, v := range r.Header {
        fmt.Fprintf(w, "Header[%q] = %q\n", k, v)
    }
    fmt.Fprintf(w, "Host = %q\n", r.Host)
    fmt.Fprintf(w, "RemoteAddr = %q\n", r.RemoteAddr)
    if err := r.ParseForm(); err != nil {
        log.Print(err)
    }
    for k, v := range r.Form {
        fmt.Fprintf(w, "Form[%q] = %q\n", k, v)
    }
}
```

これは `http.Request` 構造体のフィールドを使用して、次のような出力を生成します。
（出力例は省略）

`ParseForm` の呼び出しが `if` ステートメント内にネストされていることに注目してください。Goでは、`if` の条件の前にローカル変数の宣言などの単純なステートメントを置くことができ、この例のようなエラー処理に特に便利です。次のように書くこともできます。
```go
err := r.ParseForm()
if err != nil {
    log.Print(err)
}
```
しかし、ステートメントを組み合わせる方が短く、変数 `err` のスコープ（scope）を狭めることができるため、良い習慣とされています。スコープについてはセクション2.7で定義します。

これらのプログラムでは、出力ストリームとして使用される3つの大きく異なる型を見てきました。`fetch` プログラムはHTTPレスポンスデータをファイルである `os.Stdout` にコピーし、`lissajous` プログラムも同様でした。`fetchall` プログラムはレスポンスを（長さをカウントしながら）`ioutil.Discard` という空の出力先にコピーすることで破棄しました。そして、上記のウェブサーバーは `fmt.Fprintf` を使用して、ウェブブラウザを表す `http.ResponseWriter` に書き込みました。

これら3つの型は詳細な動作は異なりますが、すべて共通の **インターフェース（interface）** を満たしており、出力ストリームが必要な場所であればどこでも使用できます。そのインターフェースは `io.Writer` と呼ばれ、セクション7.1で詳しく説明します。

Goのインターフェース・メカニズムは第7章のテーマですが、その能力を理解するために、ウェブサーバーと `lissajous` 関数を組み合わせて、アニメーションGIFを標準出力ではなくHTTPクライアントに書き込むのがいかに簡単かを見てみましょう。ウェブサーバーに次の行を追加するだけです。
```go
handler := func(w http.ResponseWriter, r *http.Request) {
    lissajous(w)
}
http.HandleFunc("/", handler)
```

`HandleFunc` 関数の2番目の引数は **関数リテラル（function literal）**、つまり使用場所で定義された無名関数です。これについてはセクション5.6で詳しく説明します。

**練習問題 1.12:** URLからパラメータ値を読み取るようにLissajousサーバーを修正してください。例えば、`http://localhost:8000/?cycles=20` のようなURLで、サイクル数をデフォルトの5ではなく20に設定できるようにします。文字列パラメータを整数に変換するには `strconv.Atoi` 関数を使用してください。

### 1.8. 細かい点 (Loose Ends)

この簡単な導入で扱った以上に、Goにはまだ多くのことがあります。ここでは、私たちがほとんど触れなかったか、完全に省略したいくつかのトピックについて、本格的な説明の前に簡単に登場してもらえるように十分な議論を加えて紹介します。

**制御フロー (Control flow):** `if` と `for` という2つの基本的な制御フロー文については説明しましたが、多分岐の `switch` 文については説明しませんでした。小さな例を以下に示します。

```go
switch coinflip() {
case "heads":
    heads++
case "tails":
    tails++
default:
    fmt.Println("landed on edge!")
}
```

`coinflip` の呼び出し結果は各 `case` の値と比較されます。`case` は上から下に評価され、最初に一致したものが実行されます。オプションの `default` ケースは、他のどのケースも一致しない場合に一致します。これはどこにでも配置できます。C言語のような言語とは異なり、ケースは次のケースにフォールスルーしません（ただし、この動作を上書きする、めったに使用されない `fallthrough` 文は存在します）。

`switch` はオペランドを必要としません。単に `case` をリストするだけでよく、それぞれの `case` はブール式です。例：

```go
func Signum(x int) int {
    switch {
    case x > 0:
        return +1
    default:
        return 0
    case x < 0:
        return -1
    }
}
```

この形式は **タグレススイッチ (tagless switch)** と呼ばれ、`switch true` と同じです。

`break` と `continue` 文は制御フローを変更します。`break` は、最も内側の `for`、`switch`、または `select` 文（これについては後で説明します）の次の文で制御が再開されるようにします。そして、セクション1.3で見たように、`continue` は最も内側の `for` ループが次のイテレーションを開始するようにします。`break` と `continue` がそれらを参照できるように文にラベルを付けることができます。たとえば、複数のネストされたループから一度に抜け出すためや、最も外側のループの次のイテレーションを開始するためです。`goto` 文さえ存在しますが、これはプログラマによる通常の利用のためではなく、機械生成コードを意図しています。

**名前付き型 (Named types):** 型宣言により、既存の型に名前を付けることができます。`struct` 型はしばしば長いため、ほとんど常に名前が付けられます。よく知られた例として、2次元グラフィックスシステムのための `Point` 型の定義があります。

```go
type Point struct {
    X, Y int
}
var p Point
```

型宣言と名前付き型については第2章で説明します。

**ポインタ (Pointers):** Goはポインタ、つまり変数のアドレスを含む値を提供します。一部の言語、特にCでは、ポインタは比較的制約がありません。他の言語では、ポインタは「参照」として偽装され、それらを渡す以外にはあまりできることがありません。Goはその中間的な位置を取ります。ポインタは明示的に表示されます。`&` 演算子は変数のアドレスを生成し、`*` 演算子はポインタが参照する変数を取得しますが、ポインタ演算はありません。ポインタについてはセクション2.3.2で説明します。

**メソッドとインターフェース (Methods and interfaces):** メソッドは名前付き型に関連付けられた関数です。Goは、ほとんどすべての名前付き型にメソッドをアタッチできる点で珍しいです。メソッドについては第6章で説明します。インターフェースは抽象型であり、表現方法や実装方法ではなく、持っているメソッドに基づいて異なる具体的な型を同じ方法で扱うことができます。インターフェースは第7章のテーマです。

**パッケージ (Packages):** Goには有用なパッケージの広範な標準ライブラリが付属しており、Goコミュニティはさらに多くのパッケージを作成し共有しています。プログラミングは、多くの場合、自分自身でオリジナルのコードを書くことよりも、既存のパッケージを使用することの方が重要です。本書全体を通して、最も重要な標準パッケージをいくつか指摘しますが、言及するスペースがないものがさらに多くあり、どのパッケージについても完全なリファレンスを遠隔でも提供することはできません。

新しいプログラムに着手する前に、すでに存在するパッケージがより簡単に仕事をこなすのに役立つかどうかを確認することは良い考えです。標準ライブラリパッケージのインデックスは https://golang.org/pkg で、コミュニティによって貢献されたパッケージは https://godoc.org で見つけることができます。`go doc` ツールは、これらのドキュメントをコマンドラインから簡単にアクセスできるようにします。

```sh
$ go doc http.ListenAndServe
package http // import "net/http"
func ListenAndServe(addr string, handler Handler) error
ListenAndServe listens on the TCP network address addr and then
calls Serve with handler to handle requests on incoming connections.
...
```

**コメント (Comments):** プログラムやパッケージの冒頭におけるドキュメンテーションコメントについてはすでに言及しました。各関数の宣言の前にその動作を特定するコメントを記述することも良いスタイルです。これらの慣習は重要です。なぜなら、それらは `go doc` や `godoc` のようなツールによってドキュメントを見つけて表示するために使用されるからです（§10.7.4）。

複数行にわたるコメントや、式や文の中に現れるコメントには、他の言語でおなじみの `/* ... */` 表記もあります。このようなコメントは、大規模な説明テキストブロックのためにファイルの冒頭で使用されることがあり、すべての行に `//` をつけるのを避けます。コメント内では、`//` や `/*` は特別な意味を持たないため、コメントはネストしません。

```go
/* This is a multi-line comment.
   It can span multiple lines.
*/
```
