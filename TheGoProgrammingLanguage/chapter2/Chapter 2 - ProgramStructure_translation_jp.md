## プログラムの構造

Goでは、他のプログラミング言語と同様に、一連の基本的な構成要素から大きなプログラムを構築します。変数は値を格納します。単純な式は、加算や減算などの演算によってより大きな式に結合されます。基本的な型は、配列や構造体などの集合体にまとめられます。式は、`if`や`for`などの制御フロー文によって実行順序が決定される文の中で使用されます。文は、分離と再利用のために関数にグループ化されます。関数は、ソースファイルとパッケージに集められます。

前の章でこれらのほとんどの例を見ました。この章では、Goプログラムの基本的な構造要素についてさらに詳しく説明します。サンプルプログラムは意図的に単純にしてあるので、複雑なアルゴリズムやデータ構造に気を取られることなく、言語に集中できます。

### 2.1. 名前

Goの関数、変数、定数、型、文ラベル、およびパッケージの名前は、単純な規則に従います。名前は文字（Unicodeが文字と見なすもの）またはアンダースコアで始まり、任意の数の追加の文字、数字、およびアンダースコアを持つことができます。大文字と小文字は区別されます:`heapSort`と`Heapsort`は異なる名前です。

Goには、`if`や`switch`のような25のキーワードがあり、構文が許可する場所でのみ使用できます。名前として使用することはできません。

```
break      default        func         interface    select
case       defer          go           map          struct
chan       else           goto         package      switch
const      fallthrough    if           range        type
continue   for            import       return       var
```

さらに、`int`や`true`のような、組み込みの定数、型、および関数のための約3ダズンの事前宣言された名前があります。

**定数 (Constants):** `true` `false` `iota` `nil`
**型 (Types):** `int` `int8` `int16` `int32` `int64`
`uint` `uint8` `uint16` `uint32` `uint64` `uintptr`
`float32` `float64` `complex128` `complex64`
`bool` `byte` `rune` `string` `error`
**関数 (Functions):** `make` `len` `cap` `new` `append` `copy` `close` `delete`
`complex` `real` `imag`
`panic` `recover`

これらの名前は予約されていないので、宣言で使用できます。それらの1つを再宣言することが理にかなっているいくつかの場所がありますが、混乱の可能性に注意してください。

エンティティが関数内で宣言されている場合、それはその関数に対してローカルです。ただし、関数の外で宣言されている場合は、それが属するパッケージのすべてのファイルで表示されます。名前の最初の文字の大文字小文字は、パッケージの境界を越えた可視性を決定します。名前が大文字で始まる場合、それはエクスポートされます。つまり、`fmt`パッケージの`Printf`のように、独自のパッケージの外部で表示およびアクセス可能であり、プログラムの他の部分から参照できます。パッケージ名自体は常に小文字です。

名前の長さに制限はありませんが、Goプログラムの慣例とスタイルは、特にスコープが小さいローカル変数に対して、短い名前を好む傾向があります。`theLoopIndex`よりも`i`という名前の変数を見る可能性がはるかに高いです。一般に、名前のスコープが広いほど、名前はより長く、より意味のあるものである必要があります。

スタイル的には、Goプログラマーは、単語を組み合わせて名前を形成するときに「キャメルケース」を使用します。つまり、内側のアンダースコアよりも内側の文字が優先されます。したがって、標準ライブラリには、`QuoteRuneToASCII`や`parseRequestLine`のような名前の関数がありますが、`quote_rune_to_ASCII`や`parse_request_line`はありません。ASCIIやHTMLのような頭字語や頭文字の文字は常に同じケースでレンダリングされるため、関数は`htmlEscape`、`HTMLEscape`、または`escapeHTML`と呼ばれる可能性がありますが、`escapeHtml`ではありません。

### 2.2. 宣言 (Declarations)
宣言は、プログラムのエンティティに名前を付け、そのプロパティの一部またはすべてを指定します。主要な宣言には `var`、`const`、`type`、`func` の4種類があります。この章では変数と型について、第3章では定数について、第5章では関数について説明します。

Goプログラムは、名前が `.go` で終わる1つ以上のファイルに保存されます。各ファイルは、そのファイルが属するパッケージを示す `package` 宣言から始まります。`package` 宣言の後には、任意の `import` 宣言が続き、その後、パッケージレベルの型、変数、定数、および関数の宣言が任意の順序で続きます。例えば、次のプログラムは定数、関数、およびいくつかの変数を宣言しています。

```go
gopl.io/ch2/boiling
// Boiling prints the boiling point of water.
package main
import "fmt"

const boilingF = 212.0

func main() {
    var f = boilingF
    var c = (f - 32) * 5 / 9
    fmt.Printf("boiling point = %g°F or %g°C\n", f, c)
    // Output:
    // boiling point = 212°F or 100°C
}
```

定数 `boilingF` は（`main` と同様に）パッケージレベルの宣言ですが、変数 `f` と `c` は `main` 関数にローカルです。パッケージレベルの各エンティティの名前は、その宣言を含むソースファイル全体だけでなく、パッケージのすべてのファイルで可視です。対照的に、ローカル宣言は、それが宣言されている関数内でのみ、そしておそらくはそのごく一部でのみ可isibleです。

関数宣言には、名前、パラメータのリスト（関数の呼び出し元によって値が提供される変数）、オプションの結果のリスト、および関数が何をするかを定義するステートメントを含む関数本体があります。関数が何も返さない場合、結果リストは省略されます。関数の実行は最初のステートメントから始まり、`return` ステートメントに遭遇するか、結果のない関数の終わりに達するまで続きます。その後、制御とすべての結果が呼び出し元に返されます。

これまでにかなりの数の関数を見てきましたが、第5章での広範な議論を含め、これからさらに多くの関数が登場するため、これはほんの概略です。以下の `fToC` 関数は、温度変換ロジックをカプセル化しているため、一度だけ定義すれば複数の場所から使用できます。ここで、`main` はそれを2回呼び出し、2つの異なるローカル定数の値を使用しています。

```go
gopl.io/ch2/ftoc
// Ftoc prints two Fahrenheit-to-Celsius conversions.
package main
import "fmt"

func main() {
    const freezingF, boilingF = 32.0, 212.0
    fmt.Printf("%g°F = %g°C\n", freezingF, fToC(freezingF)) // "32°F = 0°C"
    fmt.Printf("%g°F = %g°C\n", boilingF, fToC(boilingF)) // "212°F = 100°C"
    func fToC(f float64) float64 {
        return (f - 32) * 5 / 9
    }
}
```

### 2.3. 変数 (Variables)
`var` 宣言は、特定の型の変数を作成し、それに名前を付け、初期値を設定します。各宣言は、次の一般的な形式をとります。
```go
var name type = expression
```
`type` または `= expression` の部分は省略できますが、両方を省略することはできません。`type` が省略された場合、その型は初期化子の式によって決定されます。`expression` が省略された場合、初期値はその型の*ゼロ値*になります。これは、数値の場合は `0`、ブーリアン値の場合は `false`、文字列の場合は `""`、インターフェースおよび参照型（スライス、ポインタ、マップ、チャネル、関数）の場合は `nil` です。配列や構造体のような集合体のゼロ値は、そのすべての要素またはフィールドがゼロ値になります。

ゼロ値の仕組みにより、変数は常にその型の明確に定義された値を保持することが保証されます。Goには、未初期化変数というものはありません。これにより、コードが簡素化され、余分な作業なしに境界条件で賢明な動作が保証されることがよくあります。例えば、
```go
var s string
fmt.Println(s) // ""
```

は何らかのエラーや予測不能な動作を引き起こすのではなく、空の文字列を出力します。Goプログラマは、より複雑な型のゼロ値が意味を持つようにしばしば努力し、変数が有用な状態で「生命」を始めるようにします。

一致する式のリストを使用して、単一の宣言で一連の変数を宣言し、任意で初期化することが可能です。
```go
var i, j, k int                 // int, int, int
var b, f, s = true, 2.3, "four" // bool, float64, string
```
初期化子には、リテラル値または任意の式を使用できます。パッケージレベルの変数は `main` が始まる前に初期化され（§2.6.2）、ローカル変数は関数の実行中にその宣言が遭遇したときに初期化されます。

複数の値を返す関数を呼び出すことによって、一連の変数を初期化することもできます。
```go
var f, err = os.Open(name) // os.Openはファイルとエラーを返します
```

#### 2.3.1. 短い変数宣言 (Short Variable Declarations)
関数内では、*短い変数宣言*と呼ばれる代替形式を使用して、ローカル変数を宣言および初期化できます。これは `name := expression` の形式をとり、`name` の型は `expression` の型によって決定されます。以下は、`lissajous` 関数（§1.4）における多くの短い変数宣言のうちの3つです。
```go
anim := gif.GIF{LoopCount: nframes}
freq := rand.Float64() * 3.0
t := 0.0
```
その簡潔さと柔軟性のため、短い変数宣言は、ローカル変数の大部分を宣言および初期化するために使用されます。`var` 宣言は、初期化子の式の型とは異なる明示的な型が必要なローカル変数や、後で値が代入され、その初期値が重要でない場合のために予約される傾向があります。
```go
i := 100                 // int
var boiling float64 = 100 // float64
var names []string
var err error
var p Point
```
`var` 宣言と同様に、同じ短い変数宣言で複数の変数を宣言および初期化できます。
```go
i, j := 0, 1
```
ただし、複数の初期化子式を持つ宣言は、`for` ループの初期化部分のような、短くて自然なグループ化のように、読みやすさを向上させる場合にのみ使用すべきです。

`:=` は*宣言*であり、`=` は*代入*であることを覚えておいてください。複数変数の宣言を、左辺の各変数に右辺の対応する値が代入される*タプル代入*（§2.4.1）と混同しないでください。
```go
i, j = j, i // iとjの値を交換
```
通常の `var` 宣言と同様に、短い変数宣言は、`os.Open` のように2つ以上の値を返す関数の呼び出しに使用できます。
```go
f, err := os.Open(name)
if err != nil {
    return err
}
// ...fを使用...
f.Close()
```
微妙ながら重要な点が1つあります。短い変数宣言は、必ずしもその左辺のすべての変数を宣言するわけではありません。それらの一部が同じ*字句ブロック*（§2.7）で既に宣言されていた場合、短い変数宣言はそれらの変数への代入として機能します。

以下のコードでは、最初のステートメントが `in` と `err` の両方を宣言します。2番目のステートメントは `out` を宣言しますが、既存の `err` 変数には値を代入するだけです。
```go
in, err := os.Open(infile)
// ...
out, err := os.Create(outfile)
```
ただし、短い変数宣言は少なくとも1つの新しい変数を宣言する必要があるため、このコードはコンパイルされません。
```go
f, err := os.Open(infile)
// ...
f, err := os.Create(outfile) // コンパイルエラー：新しい変数がない
```
修正方法は、2番目のステートメントに通常の代入を使用することです。

#### 2.3.2. ポインタ (Pointers)
変数は値を格納するストレージの一部です。宣言によって作成された変数は `x` のように名前で識別されますが、多くの変数は `x[i]` や `x.f` のような式によってのみ識別されます。これらの式はすべて変数の値を読み取りますが、代入の左辺に現れる場合は例外で、その場合は変数に新しい値が代入されます。

ポインタ値は変数の*アドレス*です。したがって、ポインタは値が格納されている場所です。すべての値がアドレスを持つわけではありませんが、すべての変数はアドレスを持ちます。ポインタを使用すると、変数の名前を使用したり知なくても、間接的に変数の値を読み取ったり更新したりできます。

`var x int` と宣言された変数がある場合、式 `&x`（「`x` のアドレス」）は整数変数へのポインタ、つまり `*int` 型の値（「intへのポインタ」と発音されます）を生成します。この値を `p` と呼ぶ場合、「`p` は `x` を指す」、または同等に「`p` は `x` のアドレスを含む」と言います。`p` が指す変数は `*p` と書かれます。式 `*p` はその変数の値（int）を生成しますが、`*p` は変数を表すため、代入の左辺にも現れることがあり、その場合、代入は変数を更新します。
```go
x := 1
p := &x         // pは*int型でxを指す
fmt.Println(*p) // "1"
*p = 2          // x = 2 と同等
fmt.Println(x)  // "2"
```
集合型変数の各コンポーネント（構造体のフィールドや配列の要素）も変数であり、したがってアドレスも持ちます。

変数はときどき*アドレス指定可能な値*として記述されます。変数を表す式は、アドレス演算子 `&` を適用できる唯一の式です。

ポインタのゼロ値は `nil` です。`p != nil` のテストは、`p` が変数を指している場合に `true` になります。ポインタは比較可能です。2つのポインタは、同じ変数を指している場合、または両方が `nil` の場合に限り等しいです。
```go
var x, y int
fmt.Println(&x == &x, &x == &y, &x == nil) // "true false false"
```
関数がローカル変数のアドレスを返すことは完全に安全です。例えば、以下のコードでは、`f` へのこの特定の呼び出しによって作成されたローカル変数 `v` は、呼び出しが返された後も存在し続け、ポインタ `p` は引き続きそれを参照します。
```go
var p = f()
func f() *int {
    v := 1
    return &v
}
```
`f` の各呼び出しは異なる値を返します。
```go
fmt.Println(f() == f()) // "false"
```
ポインタは変数のアドレスを含むため、ポインタ引数を関数に渡すと、関数が間接的に渡された変数を更新できるようになります。例えば、この関数は引数が指す変数をインクリメントし、その変数の新しい値を返すため、式で使用できます。
```go
func incr(p *int) int {
    *p++ // pが指すものをインクリメントします。p自体は変更しません
    return *p
}
v := 1
incr(&v)              // 副作用: vは現在2
fmt.Println(incr(&v)) // "3" (そしてvは3)
```
変数からアドレスを取得したり、ポインタをコピーしたりするたびに、同じ変数を識別する新しい*エイリアス*（別名）または方法を作成します。例えば、`*p` は `v` のエイリアスです。ポインタエイリアシングは、変数の名前を使用せずに変数にアクセスできるため便利ですが、これは両刃の剣です。変数にアクセスするすべてのステートメントを見つけるには、そのすべてのエイリアスを知る必要があります。エイリアスを作成するのはポインタだけではありません。スライス、マップ、チャネルのような他の参照型、さらにはこれらの型を含む構造体、配列、インターフェースの値をコピーするときにもエイリアシングが発生します。

ポインタは `flag` パッケージの鍵であり、プログラムのコマンドライン引数を使用して、プログラム全体に分散された特定の変数の値を設定します。例として、以前の `echo` コマンドのこのバリエーションには、2つのオプションフラグがあります。`-n` は `echo` に通常出力される末尾の改行を省略させ、`-s sep` は出力引数をデフォルトの単一スペースではなく文字列 `sep` の内容で区切らせます。これが4番目のバージョンなので、パッケージは `gopl.io/ch2/echo4` と呼ばれます。

gopl.io/ch2/echo4
```go
// Echo4はコマンドライン引数を出力します。
package main

import (
    "flag"
    "fmt"
    "strings"
)

var n = flag.Bool("n", false, "末尾の改行を省略する")
var sep = flag.String("s", " ", "区切り文字")

func main() {
    flag.Parse()
    fmt.Print(strings.Join(flag.Args(), *sep))
    if !*n {
        fmt.Println()
    }
}
```
関数 `flag.Bool` は、`bool` 型の新しいフラグ変数を作成します。これは3つの引数をとります。フラグの名前（"n"）、変数のデフォルト値（`false`）、およびユーザーが無効な引数、無効なフラグ、または `-h` または `-help` を提供した場合に表示されるメッセージです。同様に、`flag.String` は名前、デフォルト値、およびメッセージを受け取り、`string` 変数を作成します。変数 `sep` と `n` はフラグ変数へのポインタであり、`*sep` と `*n` として間接的にアクセスする必要があります。

プログラムが実行されるとき、フラグが使用される前に `flag.Parse` を呼び出す必要があります。これにより、フラグ変数がデフォルト値から更新されます。フラグではない引数は、`flag.Args()` から文字列のスライスとして利用できます。`flag.Parse` がエラーを検出した場合、使用法メッセージを表示し、`os.Exit(2)` を呼び出してプログラムを終了します。

`echo` でいくつかのテストケースを実行してみましょう。
```sh
$ go build gopl.io/ch2/echo4
$ ./echo4 a bc def
a bc def
$ ./echo4 -s / a bc def
a/bc/def
$ ./echo4 -n a bc def
a bc def$
$ ./echo4 -help
Usage of ./echo4:
  -n    omit trailing newline
  -s string
        separator (default " ")
```

### 2.3.3. `new` 関数 (The `new` Function)
変数を作成するもう1つの方法は、組み込み関数 `new` を使用することです。`new(T)` という式は、`T` 型の無名変数を作成し、それを `T` のゼロ値に初期化し、そのアドレス（`*T` 型の値）を返します。
```go
p := new(int)   // pは*int型で、無名のint変数を指します
fmt.Println(*p) // "0"
*p = 2          // 無名のint変数を2に設定します
fmt.Println(*p) // "2"
```
`new` で作成された変数は、アドレスが取得された通常のローカル変数と何ら変わりありません。ただし、ダミー名を考案（および宣言）する必要がなく、`new(T)` を式で使用できる点が異なります。したがって、`new` は単なる構文上の便宜であり、根本的な概念ではありません。

以下の2つの `newInt` 関数は同じ動作をします。
```go
func newInt() *int {
    return new(int)
}
```
```go
func newInt() *int {
    var dummy int
    return &dummy
}
```
`new` の各呼び出しは、一意のアドレスを持つ異なる変数を返します。
```go
p := new(int)
q := new(int)
fmt.Println(p == q) // "false"
```
このルールには1つの例外があります。`struct{}` や `[0]int` のように、情報を持たずサイズがゼロの型を持つ2つの変数は、実装によっては同じアドレスを持つ場合があります。

`new` 関数は比較的めったに使用されません。なぜなら、最も一般的な無名変数は構造体型であり、それらには構造体リテラル構文（§4.4.1）の方が柔軟性があるためです。

`new` は組み込み関数であり、キーワードではないため、関数内で別のものに名前を再定義することが可能です。例えば：
```go
func delta(old, new int) int { return new - old } 
```
もちろん、`delta` 関数内では、組み込みの `new` 関数は利用できません。

### 2.3.4. 変数の生存期間 (Lifetime of Variables)
変数の生存期間とは、プログラムの実行中にその変数が存在する期間のことです。

パッケージレベル変数の生存期間は、プログラムの実行全体です。対照的に、ローカル変数は動的な生存期間を持ちます。宣言文が実行されるたびに新しいインスタンスが作成され、その変数は到達不能になるまで存在し、その時点でストレージが再利用される可能性があります。関数パラメータと結果もローカル変数です。それらは、それらを含む関数が呼び出されるたびに作成されます。

たとえば、セクション1.4のLissajousプログラムのこの抜粋では、
```go
for t := 0.0; t < cycles*2*math.Pi; t += res {
    x := math.Sin(t)
    y := math.Sin(t*freq + phase)
    img.SetColorIndex(size+int(x*size+0.5), size+int(y*size+0.5),
blackIndex)
}
```
`for`ループが開始されるたびに変数`t`が作成され、ループの各イテレーションで新しい変数`x`と`y`が作成されます。

ガベージコレクタは、変数のストレージを再利用できることをどのように知るのでしょうか？詳細な話はここでは必要ありませんが、基本的な考え方は、すべてのパッケージレベル変数、および現在アクティブな各関数のすべてのローカル変数が、潜在的に開始点であるか、または...
問題の変数へのパスのルートであり、ポインタやその他の種類の参照をたどって、最終的にその変数に至ります。そのようなパスが存在しない場合、変数は到達不能になり、計算の残りの部分に影響を与えることはできなくなります。

変数の存続期間は、それが到達可能であるかどうかによってのみ決定されるため、ローカル変数は、それを含むループの単一の反復を超えて存続する場合があります。それを含む関数が返された後も存在し続ける可能性があります。

コンパイラは、ローカル変数をヒープまたはスタックに割り当てることを選択できますが、おそらく驚くべきことに、この選択は、変数を宣言するために `var` または `new` が使用されたかどうかによって決定されません。

var global *int
func f() { var x int x = 1 func g() {
	y := new(int)
	*y = 1
	global = &x }
}

ここで、`x` はローカル変数として宣言されているにもかかわらず、`f` が返された後も変数 `global` から到達可能であるため、ヒープに割り当てられなければなりません。`x` は `f` からエスケープすると言います。逆に、`g` が返されると、変数 `*y` は到達不能になり、リサイクルできます。`*y` は `g` からエスケープしないため、`new` で割り当てられたにもかかわらず、コンパイラが `*y` をスタックに割り当てるのは安全です。いずれにせよ、エスケープの概念は、正しいコードを書くために心配する必要があるものではありませんが、エスケープする各変数は追加のメモリアロケーションを必要とするため、パフォーマンスの最適化中に覚えておくとよいでしょう。

ガベージコレクションは、正しいプログラムを作成する上で非常に役立ちますが、メモリについて考えるという負担から解放されるわけではありません。メモリを明示的に割り当てたり解放したりする必要はありませんが、効率的なプログラムを作成するには、変数の存続期間を意識する必要があります。たとえば、不要なポインタを、特にグローバル変数などの長命オブジェクト内の短命オブジェクトに保持すると、ガベージコレクタが短命オブジェクトを再利用できなくなります。
## 2.4 代入 (Assignments)

変数が保持する値は、代入文 (**assignment statement**) によって更新されます。最も単純な形式では、左辺に変数、`=` 記号、そして右辺に式 (**expression**) を記述します。

```go
x = 1                       // 名前付き変数 (named variable)
*p = true                   // 間接変数 (indirect variable)
person.name = "bob"         // 構造体のフィールド (struct field)
count[x] = count[x] * scale // 配列、スライス、またはマップの要素
```

算術およびビット単位の各二項演算子には、対応する代入演算子があります。例えば、先ほどの最後の文は次のように書き換えることができます。

```go
count[x] *= scale
```

これにより、変数の式を繰り返す（そして再評価する - **re-evaluate**）手間を省くことができます。

数値変数は、`++` および `--` 文によってインクリメント (**increment**) またはデクリメント (**decrement**) することもできます。

```go
v := 1
v++    // v = v + 1 と同じ。v は 2 になる
v--    // v = v - 1 と同じ。v は再び 1 になる
```

## 2.4.1 タプル代入 (Tuple Assignment)

**タプル代入** (tuple assignment) と呼ばれる別の形式の代入では、一度に複数の変数を代入できます。右辺のすべての式は、変数が更新される前に評価 (**evaluated**) されます。これにより、いくつかの変数が代入の両側に現れる場合に非常に便利です。例えば、2つの変数の値を交換 (**swapping**) する場合などです。

```go
x, y = y, x
a[i], a[j] = a[j], a[i]
```

あるいは、2つの整数の最大公約数 (GCD) を計算する場合：

```go
func gcd(x, y int) int {
    for y != 0 {
        x, y = y, x%y
    }
    return x
}
```

あるいは、n番目のフィボナッチ数を反復的に (**iteratively**) 計算する場合：

```go
func fib(n int) int {
    x, y := 0, 1
    for i := 0; i < n; i++ {
        x, y = y, x+y
    }
    return x
}
```

タプル代入は、一連の単純な代入をよりコンパクト (**compact**) にすることもできます。

```go
i, j, k = 2, 3, 5
```

ただし、スタイル (**style**) の問題として、式が複雑な場合はタプル形式を避けてください。別々の文にした方が読みやすくなります。

複数の結果を返す関数呼び出しなど、特定の式は複数の値を生成します。そのような呼び出しが代入文で使用される場合、左辺には関数が返す結果の数と同じだけの変数が必要です。

```go
f, err = os.Open("foo.txt") // 関数呼び出しは2つの値を返す
```

多くの場合、関数はこれらの追加の結果を使用して、`os.Open` の呼び出しのように `error` を返すか、通常 `ok` と呼ばれる `bool` を返すことで、何らかのエラーを示します。後の章で見るように、時にはこのように振る舞う3つの演算子があります。マップ検索 (**map lookup**) (§4.3)、型アサーション (**type assertion**) (§7.10)、またはチャネル受信 (**channel receive**) (§8.4.2) が2つの結果を期待する代入に現れる場合、それぞれが追加のブール結果を生成します。

```go
v, ok = m[key] // マップ検索
v, ok = x.(T)  // 型アサーション
v, ok = <-ch   // チャネル受信
```

変数宣言と同様に、不要な値を **ブランク識別子** (blank identifier) に代入することができます。

```go
_, err = io.Copy(dst, src) // バイト数を破棄 (discard byte count)
_, ok = x.(T)              // 型をチェックするが結果は破棄 (discard result)
```

## 2.4.2 代入可能性 (Assignability)

代入文は明示的 (**explicit**) な代入形式ですが、プログラム内の多くの場所で代入が暗黙的 (**implicitly**) に発生します。関数呼び出しは引数の値 (**argument values**) を対応するパラメータ変数に暗黙的に代入し、`return` 文は戻り値のオペランドを対応する結果変数に暗黙的に代入します。また、次のようなスライスなどの複合型 (**composite type**) のリテラル式も：

```go
medals := []string{"gold", "silver", "bronze"}
```

次のように書かれたかのように、各要素を暗黙的に代入します：

```go
medals[0] = "gold"
medals[1] = "silver"
medals[2] = "bronze"
```

マップやチャネルの要素は、通常の変数ではありませんが、同様の暗黙的な代入の対象となります。

明示的か暗黙的かを問わず、代入は左辺（変数）と右辺（値）が同じ型であれば常に正当です。より一般的には、値が変数の型に対して代入可能 (**assignable**) である場合に限り、代入は正当となります。

代入可能性の規則にはさまざまな型に応じたケースがあるため、新しい型を導入する際に関連するケースを説明します。これまでに説明した型については、規則は単純です。型が正確に一致している必要があり、`nil` はインターフェース型または参照型 (**reference type**) の任意の変数に代入できます。定数 (**Constants**) には、ほとんどの明示的な型変換を回避できる、より柔軟な代入可能性の規則があります。

2つの値を `==` および `!=` で比較できるかどうかは、代入可能性に関連しています。任意の比較において、最初のオペランドは2番目のオペランドの型に代入可能であるか、またはその逆である必要があります。代入可能性と同様に、各新しい型を提示する際に比較可能性 (**comparability**) に関する関連ケースを説明します。

## 2.5 型宣言 (Type Declarations)

変数や式の型は、その値が取り得る特性を定義します。例えば、サイズ（ビット数や要素数）、内部での表現方法、それらに対して実行できる固有の演算 (**intrinsic operations**)、およびそれらに関連付けられたメソッド (**methods**) などです。

どのようなプログラムにおいても、同じ表現を共有しながらも、全く異なる概念を意味する変数があります。例えば、`int` はループのインデックス、タイムスタンプ (**timestamp**)、ファイル記述子 (**file descriptor**)、または月を表すために使用されるかもしれません。`float64` は秒速メートル単位の速度や、いくつかのスケールのいずれかによる温度を表すかもしれません。また、`string` はパスワードや色の名前を表すかもしれません。

**型宣言** (type declaration) は、既存の型と同じ**基底型** (underlying type) を持つ、新しい名前付きの型を定義します。名前付きの型は、基底型の異なる、あるいは互換性のない用途を分離する方法を提供し、それらが意図せず混ざらないようにします。

```go
type name underlying-type
```

型宣言はパッケージレベルで現れることが最も多く、その場合、名前付きの型はパッケージ全体で表示されます。また、名前がエクスポートされている場合（大文字で始まる場合）、他のパッケージからもアクセス可能です。

型宣言を説明するために、異なる温度スケールを異なる型にしてみましょう：

```go
// tempconv パッケージは Celsius（摂氏）と Fahrenheit（華氏）の温度計算を行います。
package tempconv

import "fmt"

type Celsius float64
type Fahrenheit float64

const (
    AbsoluteZeroC Celsius = -273.15
    FreezingC     Celsius = 0
    BoilingC      Celsius = 100
)

func CToF(c Celsius) Fahrenheit { return Fahrenheit(c*9/5 + 32) }
func FToC(f Fahrenheit) Celsius { return Celsius((f - 32) * 5 / 9) }
```

このパッケージは、2つの温度単位のために `Celsius` と `Fahrenheit` という2つの型を定義しています。どちらも同じ基底型 `float64` を持っていますが、同じ型ではないため、比較したり、算術式で組み合わせたりすることはできません。型を区別することで、2つの異なるスケールの温度を不注意に組み合わせてしまうようなエラーを避けることができます。`float64` から変換するには、`Celsius(t)` や `Fahrenheit(t)` のような明示的な型変換 (**explicit type conversion**) が必要です。

一方、`CToF` と `FToC` 関数は2つのスケール間で変換を行います。これらは異なる値を返します。

すべての型 `T` に対して、値 `x` を型 `T` に変換する、対応する変換演算 `T(x)` があります。両方が同じ基底型を持っている場合、または両方が同じ基底型の変数を指す名前のないポインタ型である場合、ある型から別の型への変換が許可されます。これらの変換は型を変更しますが、値の表現は変更しません。`x` が `T` に代入可能であれば、変換は許可されますが、通常は冗長 (**redundant**) です。

数値型間、および文字列と一部のスライス型間の変換も許可されています。これらの変換は値の表現を変更する可能性があります。例えば、浮動小数点数を整数に変換すると小数部分が破棄され、文字列を `[]byte` スライスに変換すると文字列データのコピーが割り当てられます。いかなる場合でも、変換が実行時に失敗することはありません。

名前付きの型の基底型は、その構造と表現、およびそれがサポートする固有の演算のセットを決定します。これらは、基底型が直接使用された場合と同じです。つまり、`Celsius` と `Fahrenheit` に対する算術演算子は、`float64` の場合と同様に機能します。

```go
fmt.Printf("%g
", BoilingC-FreezingC) // "100" °C
boilingF := CToF(BoilingC)
fmt.Printf("%g
", boilingF-CToF(FreezingC)) // "180" °F
fmt.Printf("%g
", boilingF-FreezingC) // コンパイルエラー: 型の不一致
```

`==` や `<` のような比較演算子も、名前付きの型の値を同じ型の別の値、または基底型の値と比較するために使用できます。しかし、異なる名前付きの型の2つの値を直接比較することはできません：

```go
var c Celsius
var f Fahrenheit
fmt.Println(c == 0) // "true"
fmt.Println(f >= 0) // "true"
fmt.Println(c == f) // コンパイルエラー: 型の不一致
fmt.Println(c == Celsius(f)) // "true"!
```

名前付きの型は、複雑な型を何度も書き出すのを避けるのに役立つ場合、記法上の便宜 (**notational convenience**) を提供します。基底型が `float64` のように単純な場合、利点は小さいですが、構造体 (**structs**) のように複雑な型の場合は大きくなります。

名前付きの型はまた、その型の値に対して新しい振る舞いを定義することを可能にします。これらの振る舞いは、型に関連付けられた関数のセットとして表現され、型の**メソッド** (methods) と呼ばれます。

以下の宣言では、`Celsius` 型に、`c` の数値の後に `°C` を付けて返す `String` という名前のメソッドを関連付けています：

```go
func (c Celsius) String() string { return fmt.Sprintf("%g°C", c) }
```

多くの型がこの形式の `String` メソッドを宣言します。なぜなら、`fmt` パッケージによって文字列として出力される際に、その型の値がどのように表示されるかを制御できるからです。

## 2.6 パッケージとファイル (Packages and Files)

Goにおけるパッケージは、他の言語におけるライブラリやモジュールと同じ目的を果たし、**モジュール性** (modularity)、**カプセル化** (encapsulation)、**分割コンパイル** (separate compilation)、そして**再利用** (reuse) をサポートします。パッケージのソースコードは1つ以上の `.go` ファイルに存在し、通常はインポートパスで終わる名前のディレクトリにあります。例えば、`gopl.io/ch1/helloworld` パッケージのファイルは、ディレクトリ `/src/gopl.io/ch1/helloworld` に保存されています。

各パッケージは、その宣言 (**declarations**) のための独立した**名前空間** (namespace) として機能します。例えば、`image` パッケージ内では、識別子 (**identifier**) `Decode` は、`unicode/utf16` パッケージ内の同じ識別子とは異なる関数を参照します。そのパッケージの外部から関数を参照するには、`image.Decode` と `utf16.Decode` のどちらを意味するのかを明確にするために、識別子を**修飾** (qualify) する必要があります。

パッケージはまた、パッケージ外からどの名前が見えるか、すなわち**エクスポート** (exported) されるかを制御することで、情報を隠すことができます。Goでは、どの識別子がエクスポートされ、どれがされないかを支配する単純なルールがあります：エクスポートされる識別子は大文字で始まります。

基本を説明するために、私たちの温度変換ソフトウェアが人気になり、それを新しいパッケージとしてGoコミュニティで利用できるようにしたいと仮定しましょう。どうすればよいでしょうか？

前の例のバリエーションである `gopl.io/ch2/tempconv` というパッケージを作成しましょう。（ここでは、パッケージパスをより現実的なものにするために、通常の一連の例の番号付けルールを例外としています。）このパッケージ自体は、パッケージの個別のファイル内の宣言がどのようにアクセスされるかを示すために、2つのファイルに保存されています。実際のところ、このような小さなパッケージには1つのファイルしか必要ないでしょう。

型の宣言、その定数、およびそのメソッドを `tempconv.go` に配置しました。

```go
// Package tempconv は摂氏と華氏の変換を行います。
package tempconv
import "fmt"
type Celsius float64
type Fahrenheit float64
const (
AbsoluteZeroC Celsius = -273.15
FreezingC Celsius = 0
BoilingC Celsius = 100
)
func (c Celsius) String() string { return fmt.Sprintf("%g°C", c) }
func (f Fahrenheit) String() string { return fmt.Sprintf("%g°F", f) }
```

そして変換関数を `conv.go` に配置しました。

```go
package tempconv
// CToF は摂氏温度を華氏に変換します。
func CToF(c Celsius) Fahrenheit { return Fahrenheit(c*9/5 + 32) }
// FToC は華氏温度を摂氏に変換します。
func FToC(f Fahrenheit) Celsius { return Celsius((f - 32) * 5 / 9) }
```

各ファイルはパッケージ名を定義するパッケージ宣言で始まります。パッケージがインポートされると、そのメンバーは `tempconv.CToF` のように参照されます。パッケージの1つのファイルで宣言された型や定数のようなパッケージレベルの名前は、ソースコードがすべて1つのファイルにあるかのように、パッケージの他のすべてのファイルから見ることができます。`tempconv.go` は `fmt` をインポートしていますが、`conv.go` は `fmt` の何も使用していないため、インポートしていません。

パッケージレベルの定数名が大文字で始まるため、それらも `tempconv.AbsoluteZeroC` のように修飾された名前でアクセスできます。

```go
fmt.Printf("Brrrr! %v
", tempconv.AbsoluteZeroC) // "Brrrr! -273.15°C"
```

`gopl.io/ch2/tempconv` をインポートするパッケージで摂氏温度を華氏に変換するには、次のコードを書くことができます。

```go
fmt.Println(tempconv.CToF(tempconv.BoilingC)) // "212°F"
```

パッケージ宣言の直前にある**ドキュメントコメント** (doc comment) は、パッケージ全体を文書化します。**慣例的** (conventionally) に、それは図示されたスタイルの要約文で始まるべきです。各パッケージの1つのファイルのみがパッケージのドキュメントコメントを持つべきです。広範なドキュメントコメントは、多くの場合、慣例的に `doc.go` と呼ばれる独自のファイルに配置されます。

**練習問題 2.1:** ケルビン温度スケールで温度を処理するための型、定数、関数を `tempconv` に追加してください。0ケルビンは `-273.15°C` であり、1Kの差は1°Cと同じ大きさです。

## 2.6.1 インポート (Imports)

Goプログラム内では、各パッケージは**インポートパス** (import path) と呼ばれる一意の文字列によって識別されます。これらは、`"gopl.io/ch2/tempconv"` のようなインポート宣言に表示される文字列です。言語仕様 (**language specification**) は、これらの文字列がどこから来るのか、あるいは何を意味するのかを定義していません。それらを解釈するのはツールに委ねられています。goツール（第10章）を使用する場合、インポートパスは、パッケージを構成する1つ以上のGoソースファイルを含むディレクトリを**示します** (denotes)。

インポートパスに加えて、各パッケージには**パッケージ名** (package name) があります。これは、そのパッケージ宣言に表示される短い（必ずしも一意ではない）名前です。**慣例** (convention) により、パッケージの名前はインポートパスの最後の**セグメント** (segment) と一致するため、`gopl.io/ch2/tempconv` のパッケージ名が `tempconv` であると簡単に予測できます。

`gopl.io/ch2/tempconv` を使用するには、それをインポートする必要があります。

```go
// gopl.io/ch2/cf
package main

// Cf は数値引数を摂氏と華氏に変換します。
import (
	"fmt"
	"os"
	"strconv"

	"gopl.io/ch2/tempconv"
)

func main() {
	for _, arg := range os.Args[1:] {
		t, err := strconv.ParseFloat(arg, 64)
		if err != nil {
			fmt.Fprintf(os.Stderr, "cf: %v
", err)
			os.Exit(1)
		}
		f := tempconv.Fahrenheit(t)
		c := tempconv.Celsius(t)
		fmt.Printf("%s = %s, %s = %s
",
			f, tempconv.FToC(f), c, tempconv.CToF(c))
	}
}
```

インポート宣言は、インポートされたパッケージに短い名前を**結合します** (binds)。この名前はファイル全体でその内容を参照するために使用できます。上記のインポートにより、`tempconv.CToF` のような**修飾識別子** (qualified identifier) を使用して `gopl.io/ch2/tempconv` 内の名前を参照できます。デフォルトでは、短い名前はパッケージ名（この場合は `tempconv`）ですが、インポート宣言は**代替名** (alternative name) を指定して**競合** (conflict) を避けることができます（§10.3）。

`cf` プログラムは、単一の数値**コマンドライン引数** (command-line argument) を、摂氏と華氏の両方の値に変換します。

```bash
$ go build gopl.io/ch2/cf
$ ./cf 32
32°F = 0°C, 32°C = 89.6°F
$ ./cf 212
212°F = 100°C, 212°C = 413.6°F
$ ./cf -40
-40°F = -40°C, -40°C = -40°F
```

パッケージをインポートして、その後それを参照しないのはエラーです。このチェックは、コードが進化するにつれて**不要に** (unnecessary) なる**依存関係** (dependencies) を排除するのに役立ちますが、デバッグ中には**煩わしさ** (nuisance) になることがあります。例えば、`log.Print("got here!")` のようなコード行をコメントアウトすると、パッケージ名 `log` への**唯一の参照** (sole reference) が削除され、コンパイラがエラーを出力する可能性があります。この状況では、不要なインポートをコメントアウトするか削除する必要があります。

それよりも良いのは、`golang.org/x/tools/cmd/goimports` ツールを使用することです。このツールは、必要に応じてインポート宣言からパッケージを自動的に挿入および削除します。ほとんどのエディタは、ファイルを保存するたびに `goimports` を実行するように設定できます。`gofmt` ツールと同様に、Goソースファイルを**規範形式** (canonical format) で整形します。

**練習問題 2.2:** `cf` と**類似の** (analogous) **汎用** (general-purpose) 単位変換プログラムを作成してください。このプログラムは、コマンドライン引数から、または引数がない場合は標準入力から数値を読み取り、各数値を摂氏および華氏の温度、フィートおよびメートル単位の長さ、ポンドおよびキログラム単位の重量などの単位に変換します。

## 2.6.2 パッケージの初期化 (Package Initialization)

パッケージの初期化は、パッケージレベルの変数を宣言された順序で初期化することから始まりますが、**依存関係** (dependencies) がまず**解決** (resolved) されます。

```go
var a = b + c // a は3番目に初期化され、3になる
var b = f() // b は2番目に初期化され、f を呼び出して2になる
var c = 1 // c は最初に初期化され、1になる
func f() int { return c + 1 }
```

パッケージに複数の `.go` ファイルがある場合、それらはコンパイラに与えられた順序で初期化されます。goツールは、コンパイラを呼び出す前に `.go` ファイルを名前順にソートします。

パッケージレベルで宣言された各変数は、もしあればその**初期化式** (initializer expression) の値で生命を始めますが、データテーブルのような一部の変数では、初期化式がその初期値を設定する最も簡単な方法ではないかもしれません。その場合、`init` 関数メカニズムがより簡単かもしれません。どのファイルも、次のような宣言を持つ任意の数の関数を含むことができます。

```go
func init() { /* ... */ }
```

このような `init` 関数は呼び出したり参照したりすることはできませんが、それ以外は通常の関数です。各ファイル内で、`init` 関数はプログラムが開始されると、宣言された順序で自動的に実行されます。

プログラムのインポート順に、一度に1つのパッケージが初期化され、依存関係が先に解決されるため、`q` をインポートするパッケージ `p` は、`p` の初期化が始まる前に `q` が完全に初期化されていることを確信できます。初期化は下から上に進みます。`main` パッケージは最後に初期化されます。このようにして、アプリケーションの `main` 関数が始まる前に、すべてのパッケージが完全に初期化されます。

以下のパッケージは、`uint64` 値内のセットビット、つまり値が1であるビットの数を返す `PopCount` 関数を定義しています。これは**ポップカウント** (population count) と呼ばれます。これは、`init` 関数を使用して、可能な各8ビット値のルックアップテーブル `pc` を**事前計算** (pre-compute) するため、`PopCount` 関数が64ステップを実行する必要がなく、8つのテーブルルックアップの合計を返すだけで済みます。（これはビットカウントの最も速い**アルゴリズム** (algorithm) ではないことは確かですが、`init` 関数を説明するのに便利であり、値のテーブルを事前計算する方法を示すのに役立ちます。これはしばしば有用なプログラミングテクニックです。）

```go
// gopl.io/ch2/popcount
package popcount

// pc[i] は i のポップカウントです。
var pc [256]byte

func init() {
	for i := range pc {
		pc[i] = pc[i/2] + byte(i&1)
	}
}

// PopCount は x のポップカウント（セットビットの数）を返します。
func PopCount(x uint64) int {
	return int(
		pc[byte(x>>(0*8))] +
		pc[byte(x>>(1*8))] +
		pc[byte(x>>(2*8))] +
		pc[byte(x>>(3*8))] +
		pc[byte(x>>(4*8))] +
		pc[byte(x>>(5*8))] +
		pc[byte(x>>(6*8))] +
		pc[byte(x>>(7*8))])
}
```

`init` の**レンジループ** (range loop) では**インデックス** (index) のみを使用していることに注意してください。**値** (value) は不要であるため、含める必要はありません。ループは次のように書くこともできます。

```go
for i, _ := range pc {
```

`init` 関数の他の用途については、次のセクションとセクション10.5で説明します。

**練習問題 2.3:** `PopCount` を単一の式ではなくループを使用するように書き直してください。2つのバージョンの**パフォーマンス** (performance) を比較してください。（セクション11.4では、異なる実装のパフォーマンスを**体系的に比較する** (systematically compare) 方法を示しています。）

**練習問題 2.4:** `PopCount` のバージョンを、引数を64**ビット位置** (bit position) を通して**シフト** (shifting) し、毎回**最も右のビット** (rightmost bit) をテストすることでビットを数えるように書いてください。そのパフォーマンスをテーブルルックアップバージョンと比較してください。

**練習問題 2.5:** 式 `x&(x-1)` は `x` の**最も右の非ゼロビット** (rightmost non-zero bit) をクリアします。この事実を使用してビットを数える `PopCount` のバージョンを書き、その**パフォーマンスを評価** (assess its performance) してください。


## 2.7. スコープ (Scope)

**宣言 (declaration)** は、名前を関数や変数などの **プログラム実体 (program entity)** に関連付けます。宣言の **スコープ (scope)** とは、その宣言された名前が、その宣言を指すものとして使用されるソースコードの部分のことです。スコープと **生存期間 (lifetime)** を混同しないでください。宣言のスコープはプログラムテキストの領域であり、**コンパイル時 (compile-time)** の特性です。変数の生存期間は、実行中にその変数がプログラムの他の部分から参照可能である時間の範囲であり、**実行時 (run-time)** の特性です。

**構文ブロック (syntactic block)** は、関数やループの本体を囲むような、中括弧 (braces) で囲まれた文の並びです。構文ブロック内で宣言された名前は、ブロックの外からは見えません。ブロックは宣言を囲み、そのスコープを決定します。このブロックの概念を一般化して、ソースコード内で明示的に中括弧で囲まれていない宣言のグループも含めることができます。これらをすべて **語彙ブロック (lexical blocks)** と呼びます。ソースコード全体に対する語彙ブロック（**ユニバースブロック (universe block)** と呼ばれます）、各パッケージ、各ファイル、各 `for`、`if`、`switch` 文、`switch` や `select` 文の各 `case`、そしてもちろん、明示的な各構文ブロックに対して、それぞれの語彙ブロックが存在します。

宣言の語彙ブロックはそのスコープを決定し、それは大きい場合も小さい場合もあります。`int`、`len`、`true` などの **組み込み型 (built-in types)**、関数、定数の宣言はユニバースブロックにあり、プログラム全体で参照できます。関数の外、つまり **パッケージレベル (package level)** での宣言は、同じパッケージ内のどのファイルからでも参照できます。`tempconv` の例の `fmt` のような **インポートされたパッケージ (imported packages)** はファイルレベルで宣言されるため、同じファイルからは参照できますが、別のインポートがない限り、同じパッケージ内の別のファイルからは参照できません。`tempconv.CToF` 関数内の変数 `c` のような多くの宣言は **ローカル (local)** であるため、同じ関数内、あるいはその一部からしか参照できません。

`break`、`continue`、`goto` 文で使用される **制御フローラベル (control-flow label)** のスコープは、それを囲む関数全体です。

プログラムには、各宣言が異なる語彙ブロックにある限り、同じ名前の複数の宣言を含めることができます。例えば、パッケージレベルの変数と同じ名前のローカル変数を宣言できます。あるいは、セクション 2.3.3 で示したように、この名前の関数がユニバースブロックで事前に宣言されているにもかかわらず、`new` という名前の関数パラメータを宣言することができます。ただし、やりすぎないでください。再宣言のスコープが大きければ大きいほど、読者を驚かせる可能性が高くなります。

コンパイラが名前への参照に遭遇すると、最も内側の囲んでいる語彙ブロックから始めて、ユニバースブロックまで遡って宣言を探します。コンパイラが宣言を見つけられない場合、「未宣言の名前 (undeclared name)」エラーを報告します。名前が外側のブロックと内側のブロックの両方で宣言されている場合、内側の宣言が先に見つかります。その場合、内側の宣言は外側の宣言を **隠蔽 (shadow または hide)** していると言い、アクセスできなくします。

```go
func f() {}

var g = "g"

func main() {
    f := "f"
    fmt.Println(f) // "f"; ローカル変数 f はパッケージレベルの関数 f を隠蔽します
    fmt.Println(g) // "g"; パッケージレベルの変数
    fmt.Println(h) // コンパイルエラー: 未定義: h
}
```



関数内では、語彙ブロックは任意の深さまで **ネスト（入れ子）** することができるため、あるローカル宣言が別の宣言を **隠蔽 (shadow)** することがあります。ほとんどのブロックは、`if` 文や `for` ループのような制御フロー構造によって作成されます。以下のプログラムには `x` という名前の変数が3つありますが、それぞれの宣言は異なる語彙ブロックに現れるためです。（この例はスコープのルールを説明するものであり、良いスタイルを示すものではありません！）

```go
func main() {
    x := "hello!"
    for i := 0; i < len(x); i++ {
        x := x[i]
        if x != '!' {
            x := x + 'A' - 'a'
            fmt.Printf("%c", x) // "HELLO" (反復ごとに1文字)
        }
    }
}
```

式 `x[i]` と `x + 'A' - 'a'` はそれぞれ、外側のブロックからの `x` の宣言を参照しています。これについてはすぐに説明します。（後者の式は `unicode.ToUpper` と等価ではないことに注意してください。）

前述のように、すべての語彙ブロックが明示的な中括弧で区切られた文のシーケンスに対応しているわけではありません。いくつかは単に **暗黙的 (implied)** です。上記の `for` ループは2つの語彙ブロックを作成します。ループ本体のための **明示的 (explicit)** なブロックと、`i` のように **初期化節 (initialization clause)** によって宣言された変数を追加で囲む **暗黙的 (implicit)** なブロックです。暗黙的なブロックで宣言された変数のスコープは、条件式、事後文 (`i++`)、および `for` 文の本体です。

以下の例にも `x` という名前の変数が3つあり、それぞれ異なるブロック（関数本体、`for` 文のブロック、ループ本体）で宣言されていますが、明示的なブロックは2つだけです。

```go
func main() {
    x := "hello"
    for _, x := range x {
        x := x + 'A' - 'a'
        fmt.Printf("%c", x) // "HELLO" (反復ごとに1文字)
    }
}
```

`for` ループと同様に、`if` 文と `switch` 文も、本体ブロックに加えて暗黙的なブロックを作成します。以下の `if-else` チェーンのコードは、`x` と `y` のスコープを示しています。

```go
if x := f(); x == 0 {
    fmt.Println(x)
} else if y := g(x); x == y {
    fmt.Println(x, y)
} else {
    fmt.Println(x, y)
}
fmt.Println(x, y) // コンパイルエラー: ここでは x と y は見えません
```

2番目の `if` 文は最初の文の中にネストされているため、最初の文のイニシャライザ内で宣言された変数は、2番目の文の中で見ることができます。同様のルールが `switch` 文の各 `case` にも適用されます。条件のためのブロックと、各 `case` 本体のためのブロックがあります。

パッケージレベルでは、宣言が表示される順序はそのスコープに影響しないため、宣言はそれ自身やそれに続く別の宣言を参照することができ、再帰的または相互再帰的な型や関数を宣言することができます。ただし、定数や変数の宣言がそれ自身を参照している場合、コンパイラはエラーを報告します。

このプログラムでは：

```go
if f, err := os.Open(fname); err != nil { // コンパイルエラー: 未使用: f
    return err
}
f.ReadByte() // コンパイルエラー: 未定義 f
f.Close() // コンパイルエラー: 未定義 f
```

`f` のスコープは `if` 文だけなので、続く文からは `f` にアクセスできず、コンパイルエラーになります。コンパイラによっては、ローカル変数 `f` が一度も使用されなかったことを報告する追加のエラーが表示される場合があります。

したがって、後でアクセスできるようにするには、条件の前に `f` を宣言する必要があります。

```go
f, err := os.Open(fname)
if err != nil {
    return err
}
f.ReadByte()
f.Close()
```

`ReadByte` と `Close` の呼び出しを `else` ブロック内に移動することで、外側のブロックでの `f` と `err` の宣言を避けたくなるかもしれません。

```go
if f, err := os.Open(fname); err != nil {
    return err
} else {
    // f と err はここでも見えます
    f.ReadByte()
    f.Close()
}
```

しかし、Goにおける **通常の慣習 (normal practice)** では、`if` ブロックでエラーを処理してから `return` し、成功した実行パスが **インデント (字下げ)** されないようにします。

短い変数宣言 (`:=`) は、スコープへの意識を要求します。以下のプログラムを考えてみましょう。これは現在の作業ディレクトリを取得し、それをパッケージレベルの変数に保存することから始まります。これは `main` 関数で `os.Getwd` を呼び出すことでも行えますが、特にディレクトリの取得に失敗することが致命的なエラーである場合、この関心事を主要なロジックから分離する方が良いかもしれません。関数 `log.Fatalf` はメッセージを表示し、`os.Exit(1)` を呼び出します。

```go
var cwd string
func init() {
    cwd, err := os.Getwd() // コンパイルエラー: 未使用: cwd
    if err != nil {
        log.Fatalf("os.Getwd failed: %v", err)
    }
}
```

`cwd` も `err` も `init` 関数のブロック内でまだ宣言されていないため、`:=` 文はそれらの **両方** をローカル変数として宣言します。内側の `cwd` の宣言により、外側の宣言にアクセスできなくなるため、この文は意図したようにパッケージレベルの変数 `cwd` を更新しません。

現在のGoコンパイラは、ローカルの `cwd` 変数が使用されていないことを検出し、これをエラーとして報告しますが、厳密にこのチェックを行うことは必須ではありません。さらに、ローカルの `cwd` を参照するログ出力文を追加するなどの些細な変更で、このチェックを無効にすることができます。

```go
var cwd string
func init() {
    cwd, err := os.Getwd() // 注意: 間違いです！
    if err != nil {
        log.Fatalf("os.Getwd failed: %v", err)
    }
    log.Printf("Working directory = %s", cwd)
}
```

グローバルな `cwd` 変数は初期化されないままであり、一見正常なログ出力がバグを **曖昧にします (obfuscate)**。

この潜在的な問題に対処する方法はいくつかあります。最も直接的な方法は、`err` を別の `var` 宣言で宣言することで、`:=` の使用を避けることです。

```go
var cwd string
func init() {
    var err error
    cwd, err = os.Getwd()
    if err != nil {
        log.Fatalf("os.Getwd failed: %v", err)
    }
}
```

これで、パッケージ、ファイル、宣言、および文がどのようにプログラムの構造を表現するかを見てきました。次の2つの章では、データの構造を見ていきます。

