## 第1章：マイクロサービス (Microservices)

マイクロサービスアーキテクチャは、私が本書の初版を執筆してからの5年以上の間に、ますます人気のあるアーキテクチャの選択肢となりました。その後の爆発的な普及は私の手柄とは言えませんが、マイクロサービスアーキテクチャを利用しようという動きが急増したことで、以前私が取り上げた多くのアイデアが試され検証される一方で、新しいアイデアが融合し、同時に以前の慣習の一部は支持されなくなりました。そのため、改めてマイクロサービスアーキテクチャの本質を抽出し、マイクロサービスを機能させる核となる概念を強調する時が来ました。

本書全体は、マイクロサービスがソフトウェアデリバリの様々な側面に与える影響について、幅広い概要を提供することを目的としています。手始めに、本章ではマイクロサービスの背後にある核となる考え方、ここに至るまでの先行技術、そしてなぜこれらのアーキテクチャがこれほど広く使われているのか、その理由を見ていきます。

### マイクロサービスの概要 (Microservices at a Glance)

**マイクロサービス**とは、ビジネスドメイン（業務領域）を中心にモデル化された、**独立してリリース可能（independently releasable）**なサービスのことです。サービスは機能をカプセル化し、ネットワークを通じて他のサービスからアクセスできるようにします。つまり、これらの構成要素（ビルディングブロック）から、より複雑なシステムを構築するのです。あるマイクロサービスは在庫（inventory）を表し、別のサービスは注文管理（order management）、また別のサービスは配送（shipping）を表すかもしれませんが、これらが一緒になって完全なEコマースシステムを構成する場合があります。

マイクロサービスは、直面する問題を解決するための多くの選択肢を提供することに焦点を当てたアーキテクチャの選択肢です。これは**サービス指向アーキテクチャ（Service-Oriented Architecture - SOA）**の一種ですが、サービスの境界線をどのように引くべきかについて独自の意見（opinionated）を持っており、**独立したデプロイ可能性（independent deployability）**が鍵となります。また、**技術に依存しない（technology agnostic）**ことも特徴であり、これはマイクロサービスが提供する利点の一つです。

外部から見ると、単一のマイクロサービスは**ブラックボックス（black box）**として扱われます。マイクロサービスは、ビジネス機能を1つ以上の**ネットワークエンドポイント（network endpoints）**（例えば、**キュー（queue）**や**REST API**など、図1-1参照）上で、最も適切なプロトコルを介してホストします。コンシューマー（利用者）は、他のマイクロサービスであれ、その他の種類のプログラムであれ、これらのネットワーク化されたエンドポイントを通じてこの機能にアクセスします。内部の実装詳細（サービスがどの技術で書かれているか、データがどのように保存されているかなど）は、外部からは完全に隠されています。これは、マイクロサービスアーキテクチャが、ほとんどの状況において**共有データベース（shared databases）**の使用を避けることを意味します。その代わりに、各マイクロサービスは必要に応じて独自のデータベースをカプセル化します。

マイクロサービスは、**情報隠蔽（information hiding）**の概念を取り入れています。情報隠蔽とは、コンポーネントの内部に可能な限り多くの情報を隠し、外部インターフェースを介して公開する情報を可能な限り少なくすることを意味します。これにより、容易に変更できる部分と、変更がより困難な部分を明確に分離することができます。

外部から隠蔽された実装は、マイクロサービスが公開しているネットワークインターフェースが**後方互換性（backward-incompatible）**のない形で変更されない限り、自由に変更することができます。マイクロサービスの境界内部での変更（図1-1参照）は、上流のコンシューマーに影響を与えるべきではありません。これにより、機能の**独立したリリース可能性（independent releasability）**が可能になります。これは、マイクロサービスを隔離して作業し、オンデマンドでリリースできるようにするために不可欠です。

内部実装が変更されても変わらない、明確で安定したサービス境界を持つことは、**疎結合（loose coupling）**で**高凝集（strong cohesion）**なシステムをもたらします。

内部実装の詳細を隠すことについて話している間に、Alistair Cockburnによって最初に詳述された**ヘキサゴナルアーキテクチャ（Hexagonal Architecture / 六角形アーキテクチャ）**パターンについて触れないわけにはいきません。このパターンは、同じ機能に対して異なる種類のインターフェースを通じて対話したい場合があるという考えに基づき、内部実装を外部インターフェースから分離しておくことの重要性を説いています。私がマイクロサービスを六角形で描くのは、一部には「通常の」サービスと区別するためですが、この先行技術へのオマージュ（敬意）でもあります。

---
### サービス指向アーキテクチャ(SOA)とマイクロサービスは違うものか？

サービス指向アーキテクチャ（SOA）は、複数のサービスが協調して、最終的な一連の機能を提供する設計アプローチです。（ここでの「サービス」とは、通常、完全に独立したオペレーティングシステムのプロセスを意味します。）これらのサービス間の通信は、プロセス境界内のメソッド呼び出しではなく、ネットワークを介した呼び出しによって行われます。

SOAは、大規模なモノリシックなアプリケーションの課題に対処するためのアプローチとして登場しました。このアプローチは、ソフトウェアの再利用性を促進することを目的としています。例えば、2つ以上のエンドユーザーアプリケーションが同じサービスを利用することが可能です。SOAは、理論上、サービスのセマンティクス（意味）が大きく変わらない限り、あるサービスを別のサービスに誰にも知られずに置き換えることができるため、ソフトウェアの保守や書き換えを容易にすることを目指しています。

SOAはその核心において、賢明なアイデアです。しかし、多くの努力にもかかわらず、SOAをうまく実践する方法についての十分なコンセンサスが欠けています。私の意見では、業界の多くはこの問題を十分に包括的に見ることができず、この分野の様々なベンダーが打ち出した物語に対する説得力のある代替案を提示できませんでした。

SOAのせいにされる問題の多くは、実際には通信プロトコル（例：SOAP）、ベンダーのミドルウェア、サービスの粒度（service granularity）に関する指針の欠如、あるいはシステムを分割する場所を選ぶ際の誤った指針といったものの問題です。皮肉屋なら、ベンダーがより多くの製品を売るための方法としてSOA運動を便乗（そして場合によっては推進）し、その製品自体が最終的にSOAの目標を損なった、と示唆するかもしれません。

私は、チームがサービスをより小さくしようと努力しているにもかかわらず、すべてが単一のデータベースに結合され、すべてを一緒にデプロイしなければならないというSOAの例を数多く見てきました。サービス指向か？はい。しかし、それはマイクロサービスではありません。

マイクロサービスのアプローチは、システムとアーキテクチャに対する我々のより良い理解を活かし、SOAをうまく実践するために、実世界での使用から生まれました。エクストリーム・プログラミング（XP）やスクラムがアジャイルソフトウェア開発の特定のアプローチであるのと同様に、マイクロサービスはSOAの特定のアプローチであると考えるべきです。

---
